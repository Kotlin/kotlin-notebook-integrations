package org.jetbrains.kotlinx.jupyter.widget.generator

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

private val hiddenAttributeNames =
    setOf(
        "_model_name",
        "_model_module",
        "_model_module_version",
        "_view_name",
        "_view_module",
        "_view_module_version",
    )

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String?,
    val version: String,
)

public fun main() {
    val projectRoot =
        Path
            .of(".")
            .toAbsolutePath()
            .normalize()
            .parent
            ?.parent
            ?.parent
            ?: error("Unable to resolve project root")

    val generator = WidgetGenerator(projectRoot)
    generator.generate()
}

private class WidgetGenerator(
    projectRoot: Path,
) {
    private val json = Json { ignoreUnknownKeys = true }

    private val schemaPath = projectRoot / "integrations/widgets/widgets-generator/schema.json"
    private val apiOutput = projectRoot / "integrations/widgets/widgets-api/src/generated/kotlin"
    private val jupyterOutput = projectRoot / "integrations/widgets/widgets-jupyter/src/generated/kotlin"
    private val enums = mutableMapOf<String, EnumInfo>()

    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        for (widgetInfo in widgetInfos) {
            generateWidgetFile(widgetInfo)
        }
        generateEnumFiles()
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName =
            model.name?.removeSuffix("Model")
                ?: view.name?.removeSuffix("View")
                ?: error("Either model or view name must be specified")
        val className = if (baseName.endsWith("Widget")) baseName else "${baseName}Widget"
        val functionName = baseName.toCamelCase()
        return WidgetInfo(baseName, className, functionName, this)
    }

    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "$WIDGETS_PACKAGE.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val builder = StringBuilder()
        val imports =
            sortedSetOf<String>().apply {
                for (importName in listOf(
                    "WidgetManager",
                    "model.DefaultWidgetFactory",
                    "model.DefaultWidgetModel",
                    "model.WidgetSpec",
                    "model.createAndRegisterWidget",
                )) {
                    add("$WIDGETS_PACKAGE.$importName")
                }
            }

        val helperDeclarations = mutableListOf<String>()
        val properties =
            info.schema.attributes.mapNotNull { attribute ->
                if (attribute.name in hiddenAttributeNames) return@mapNotNull null
                createProperty(attribute, helperDeclarations, imports)
            }

        builder.addHeader(packageName)
        if (imports.isNotEmpty()) {
            for (import in imports) {
                builder.appendLine("import $import")
            }
            builder.appendLine()
        }

        for (declaration in helperDeclarations) {
            builder.appendLine(declaration)
            builder.appendLine()
        }

        val specName = "${info.functionName}Spec"
        builder.appendLine("private val $specName = WidgetSpec(")
        builder.appendLine("    modelName = \"${info.schema.model.name}\",")
        builder.appendLine("    modelModule = \"${info.schema.model.module}\",")
        builder.appendLine("    modelModuleVersion = \"${info.schema.model.version}\",")
        builder.appendLine("    viewName = \"${info.schema.view.name}\",")
        builder.appendLine("    viewModule = \"${info.schema.view.module}\",")
        builder.appendLine("    viewModuleVersion = \"${info.schema.view.version}\",")
        builder.appendLine(")")
        builder.appendLine()

        builder.appendLine(
            "public fun WidgetManager.${info.functionName}(): ${info.className} = createAndRegisterWidget(${info.className}.Factory)",
        )
        builder.appendLine()
        builder.appendLine("public class ${info.className} internal constructor(")
        builder.appendLine("    widgetManager: WidgetManager,")
        builder.appendLine(") : DefaultWidgetModel($specName, widgetManager) {")
        builder.appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
        builder.appendLine()

        for (property in properties) {
            builder.appendLine(property)
        }

        builder.appendLine("}")

        filePath.writeText(builder.toString())
    }

    private fun createProperty(
        attribute: AttributeSchema,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): String {
        val propertyType = attribute.toPropertyType(json, enums)

        imports.addAll(propertyType.imports)
        helperDeclarations.addAll(propertyType.helperDeclarations)

        val propertyName = attribute.name.toPascalCase().toCamelCase()
        val kotlinType = propertyType.kotlinType
        val defaultValueExpression = propertyType.getDefaultValueExpression(attribute.default)

        val delegateName = propertyType.delegateName ?: "prop"
        val typeExpressionArgument = if (propertyType.delegateName == null) ", " + propertyType.typeExpression else ""
        val delegateCall = "$delegateName(\"${attribute.name}\"$typeExpressionArgument, $defaultValueExpression)"

        return buildString {
            val help = attribute.help
            if (help.isNotEmpty()) {
                appendLine("    /** $help */")
            }
            append("    public var $propertyName: $kotlinType by $delegateCall")
        }
    }

    private fun generateEnumFiles() {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.enums"
        val directory = apiOutput / packageName.replace('.', '/')
        directory.createDirectories()

        for (enumInfo in enums.values) {
            val filePath = directory / "${enumInfo.className}.kt"
            val builder = StringBuilder()
            builder.addHeader(packageName)
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnum")
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")
            builder.appendLine()

            val entries =
                enumInfo.values.joinToString("\n") { value ->
                    val entryName = if (value.isEmpty()) "Default" else value.toPascalCase()
                    "    public val $entryName: WidgetEnumEntry<${enumInfo.className}> by entry(\"$value\")"
                }

            builder.appendLine("public object ${enumInfo.className} : WidgetEnum<${enumInfo.className}>() {")
            builder.appendLine(entries)
            builder.appendLine("}")

            filePath.writeText(builder.toString())
        }
    }

    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.className }
        val content =
            buildString {
                addHeader(packageName)
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                appendLine("import $WIDGETS_PACKAGE.model.WidgetFactory")
                appendLine()
                appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
                for (info in sortedInfos) {
                    appendLine("    ${info.className}.Factory,")
                }
                appendLine(")")
            }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGETS_PACKAGE.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.functionName }
        val content =
            buildString {
                addHeader(packageName)
                for (info in widgetInfos.sortedInImportsOrder { it.className }) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.functionName}")
                }
                appendLine()
                for (info in sortedInfos) {
                    appendLine("public fun ${info.functionName}Widget(): ${info.className} = globalWidgetManager.${info.functionName}()")
                    appendLine()
                }
            }

        filePath.writeText(content)
    }

    private fun StringBuilder.addHeader(packageName: String) {
        appendLine(GENERATED_NOTICE)
        appendLine("package $packageName")
        appendLine()
    }

    private fun <T> List<T>.sortedInImportsOrder(representAsString: (T) -> String): List<T> =
        sortedWith { a, b ->
            when {
                representAsString(a).startsWith(representAsString(b)) -> 1
                representAsString(b).startsWith(representAsString(a)) -> -1
                else -> representAsString(a).compareTo(representAsString(b))
            }
        }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files
                .walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val baseName: String,
    val className: String,
    val functionName: String,
    val schema: WidgetSchema,
)
