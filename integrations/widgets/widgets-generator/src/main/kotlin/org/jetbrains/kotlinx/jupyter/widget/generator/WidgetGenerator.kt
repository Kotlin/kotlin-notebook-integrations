package org.jetbrains.kotlinx.jupyter.widget.generator

import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText
import java.util.Comparator
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.boolean
import kotlinx.serialization.json.double
import kotlinx.serialization.json.float
import kotlinx.serialization.json.int

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String,
    val version: String,
)

@Serializable
private data class AttributeSchema(
    val name: String,
    val type: AttributeType,
    val default: JsonElement,
    @SerialName("allow_none") val allowNone: Boolean = false,
    val enum: List<String> = emptyList(),
    val help: String = "",
    val items: AttributeItems? = null,
    val widget: String? = null,
    @SerialName("union_attributes") val unionAttributes: List<AttributeSchema> = emptyList(),
)

@Serializable
private data class AttributeItems(
    val type: AttributeType,
    val widget: String? = null,
)

private object AttributeTypeSerializer {
    fun serialize(type: AttributeType): JsonElement = when (type) {
        is AttributeType.Single -> JsonPrimitive(type.name)
        is AttributeType.Union -> Json.encodeToJsonElement(type.options.map { serialize(it) })
    }
}

@Serializable(with = AttributeType.Companion::class)
private sealed class AttributeType {
    data class Single(val name: String) : AttributeType()
    data class Union(val options: List<Single>) : AttributeType()

    companion object : kotlinx.serialization.KSerializer<AttributeType> {
        private val delegate = JsonElement.serializer()

        override val descriptor = delegate.descriptor

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder): AttributeType {
            val element = delegate.deserialize(decoder)
            return when (element) {
                is JsonPrimitive -> Single(element.content)
                else -> {
                    val options = Json.decodeFromJsonElement<List<JsonPrimitive>>(element)
                    Union(options.map { Single(it.content) })
                }
            }
        }

        override fun serialize(encoder: kotlinx.serialization.encoding.Encoder, value: AttributeType) {
            encoder.encodeSerializableValue(delegate, AttributeTypeSerializer.serialize(value))
        }
    }
}

public fun main() {
    val projectRoot = Path.of(".")
        .toAbsolutePath()
        .normalize()
        .parent
        ?.parent
        ?.parent
        ?: error("Unable to resolve project root")

    val generator = WidgetGenerator(projectRoot)
    generator.generate()
}

private class WidgetGenerator(private val projectRoot: Path) {
    private val json = Json { ignoreUnknownKeys = true }

    private val schemaPath = projectRoot / "integrations/widgets/widgets-generator/schema.json"
    private val apiOutput = projectRoot / "integrations/widgets/widgets-api/src/generated/kotlin"
    private val jupyterOutput = projectRoot / "integrations/widgets/widgets-jupyter/src/generated/kotlin"

    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        widgetInfos.forEach { generateWidgetFile(it) }
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName = model.name.removeSuffix("Model")
        val className = if (baseName.endsWith("Widget")) baseName else "${baseName}Widget"
        val functionName = baseName.toCamelCase()
        return WidgetInfo(baseName, className, functionName, this)
    }

    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "org.jetbrains.kotlinx.jupyter.widget.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val builder = StringBuilder()
        val imports = sortedSetOf(
            "org.jetbrains.kotlinx.jupyter.widget.WidgetManager",
            "org.jetbrains.kotlinx.jupyter.widget.model.DefaultWidgetFactory",
            "org.jetbrains.kotlinx.jupyter.widget.model.DefaultWidgetModel",
            "org.jetbrains.kotlinx.jupyter.widget.model.WidgetSpec",
            "org.jetbrains.kotlinx.jupyter.widget.model.createAndRegisterWidget",
        )

        val helperDeclarations = mutableListOf<String>()
        val properties = info.schema.attributes.map { attribute ->
            createProperty(attribute, info, helperDeclarations, imports)
        }

        builder.appendLine(GENERATED_NOTICE)
        builder.appendLine("package $packageName")
        builder.appendLine()
        if (imports.isNotEmpty()) {
            imports.forEach { builder.appendLine("import $it") }
            builder.appendLine()
        }

        helperDeclarations.forEach { declaration ->
            builder.appendLine(declaration)
            builder.appendLine()
        }

        val specName = "${info.functionName}Spec"
        builder.appendLine("private val $specName = WidgetSpec(")
        builder.appendLine("    modelName = \"${info.schema.model.name}\",")
        builder.appendLine("    modelModule = \"${info.schema.model.module}\",")
        builder.appendLine("    modelModuleVersion = \"${info.schema.model.version}\",")
        builder.appendLine("    viewName = \"${info.schema.view.name}\",")
        builder.appendLine("    viewModule = \"${info.schema.view.module}\",")
        builder.appendLine("    viewModuleVersion = \"${info.schema.view.version}\",")
        builder.appendLine(")")
        builder.appendLine()

        builder.appendLine("public fun WidgetManager.${info.functionName}(): ${info.className} = createAndRegisterWidget(${info.className}.Factory)")
        builder.appendLine()
        builder.appendLine("public class ${info.className} internal constructor(")
        builder.appendLine("    widgetManager: WidgetManager,")
        builder.appendLine(") : DefaultWidgetModel($specName, widgetManager) {")
        builder.appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
        builder.appendLine()

        properties.forEach { builder.appendLine(it) }

        builder.appendLine("}")

        filePath.writeText(builder.toString())
    }

    private fun createProperty(
        attribute: AttributeSchema,
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): String {
        val typeInfo = attribute.toTypeInfo(widgetInfo, helperDeclarations, imports)
        return buildString {
            append("    public var ${attribute.name}: ${typeInfo.kotlinType} by ")
            append(typeInfo.delegate)
        }
    }

    private fun AttributeSchema.toTypeInfo(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        return when (type) {
            is AttributeType.Single -> toSingleTypeInfo(widgetInfo, helperDeclarations, imports)
            is AttributeType.Union -> toUnionTypeInfo(widgetInfo, helperDeclarations, imports)
        }
    }

    private fun AttributeSchema.toUnionTypeInfo(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        val nameForType = "${widgetInfo.className}${name.toPascalCase()}UnionType"
        val optionTypes = unionAttributes.ifEmpty {
            type.options.map { opt ->
                AttributeSchema(name, opt, default, allowNone, enum, help, items, widget)
            }
        }

        val candidateInfos = optionTypes.map { candidate ->
            candidate.copy(unionAttributes = emptyList()).toSingleTypeInfo(widgetInfo, helperDeclarations, imports)
        }

        val serializerSelector = "{ value ->\n        when (value) {\n${candidateInfos.joinToString(separator = "\n") { info ->
            "            is ${info.kotlinTypeWithoutNullability} -> ${info.propertyTypeExpr}"
        }}\n            else -> ${candidateInfos.last().propertyTypeExpr}\n        }\n    }"

        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.UnionType")
        val deserializers = candidateInfos.joinToString(", ") { it.propertyTypeExpr }
        val unionDeclaration = buildString {
            appendLine("private val $nameForType = UnionType<Any>(")
            appendLine("    name = \"$name\",")
            appendLine("    default = ${candidateInfos.first().defaultValue},")
            appendLine("    serializerSelector = $serializerSelector,")
            appendLine("    deserializers = listOf($deserializers),")
            appendLine(")")
        }

        helperDeclarations += unionDeclaration

        val defaultValue = candidateInfos.first().defaultValue
        return TypeInfo("Any", "prop(\"$name\", $nameForType, $defaultValue)", nameForType, defaultValue)
    }

    private fun AttributeSchema.toSingleTypeInfo(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        if (enum.isNotEmpty()) {
            return toEnumType(widgetInfo, helperDeclarations, imports)
        }

        return when ((type as AttributeType.Single).name) {
            "string" -> basicType("String", "stringProp", imports, this)
            "bool" -> basicType("Boolean", "boolProp", imports, this)
            "int" -> basicType("Int", "intProp", imports, this)
            "float" -> basicType("Double", "doubleProp", imports, this)
            "bytes" -> basicType("ByteArray", "bytesProp", imports, this)
            "Datetime" -> timedType("java.time.Instant", "org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.DatetimeType", imports)
            "Date" -> timedType("java.time.LocalDate", "org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.DateType", imports)
            "Time" -> timedType("java.time.LocalTime", "org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.TimeType", imports)
            "reference" -> referenceType(widgetInfo, imports)
            "object" -> objectType(imports)
            "array" -> arrayType(widgetInfo, helperDeclarations, imports)
            else -> error("Unsupported type ${type}")
        }
    }

    private fun AttributeSchema.objectType(imports: MutableSet<String>): TypeInfo {
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.RawObjectType")
        val nullable = allowNone || default is JsonNull
        val kotlinType = if (nullable) "Map<String, Any?>?" else "Map<String, Any?>"
        val propertyTypeExpr = if (nullable) {
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType")
            "NullableType(RawObjectType)"
        } else {
            "RawObjectType"
        }
        val delegate = "prop(\"$name\", $propertyTypeExpr, ${if (nullable) "null" else "emptyMap()"})"
        return TypeInfo(kotlinType, delegate, propertyTypeExpr, if (nullable) "null" else "emptyMap()")
    }

    private fun AttributeSchema.referenceType(
        widgetInfo: WidgetInfo,
        imports: MutableSet<String>,
    ): TypeInfo {
        val targetClass = referencedClassName()
        val defaultValue = if ((default as? JsonPrimitive)?.content == "reference to new instance") {
            "widgetManager.${targetClass.toCamelCase()}()"
        } else {
            "null"
        }

        if (targetClass == "WidgetModel") {
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.WidgetModel")
        }
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.widget.WidgetReferenceType")
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType")

        val kotlinType = "$targetClass?"
        val delegate = "widgetProp(\"$name\", $defaultValue)"
        return TypeInfo(kotlinType, delegate, "WidgetReferenceType<$targetClass>()", defaultValue)
    }

    private fun AttributeSchema.arrayType(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        val elementInfo = if (items == null) {
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.primitive.AnyType")
            TypeInfo("Any?", "prop(\"$name-item\", AnyType, null)", "AnyType", "null")
        } else {
            items.toElementType(widgetInfo, helperDeclarations, imports)
        }
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.ArrayType")
        val propertyTypeExpr = "ArrayType(${elementInfo.propertyTypeExpr})"
        val defaultValue = defaultArrayValue(elementInfo.kotlinTypeWithoutNullability, elementInfo.kotlinType, default)
        val delegate = "prop(\"$name\", $propertyTypeExpr, $defaultValue)"
        return TypeInfo("List<${elementInfo.kotlinType}>", delegate, propertyTypeExpr, defaultValue)
    }

    private fun AttributeItems.toElementType(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        val schema = AttributeSchema(name = "item", type = type, default = JsonNull, widget = widget)
        return schema.toSingleTypeInfo(widgetInfo, helperDeclarations, imports)
    }

    private fun AttributeSchema.timedType(
        kotlinType: String,
        typeImport: String,
        imports: MutableSet<String>,
    ): TypeInfo {
        imports.add(typeImport)
        val propertyTypeExpr = typeImport.substringAfterLast('.')
        val nullable = allowNone || default is JsonNull
        val actualTypeExpr = if (nullable) {
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType")
            "NullableType($propertyTypeExpr)"
        } else {
            propertyTypeExpr
        }
        val kotlinTypeName = if (nullable) "$kotlinType?" else kotlinType
        val defaultValue = defaultValueForType(kotlinTypeName, default)
        val delegate = "prop(\"$name\", $actualTypeExpr, $defaultValue)"
        return TypeInfo(kotlinTypeName, delegate, actualTypeExpr, defaultValue)
    }

    private fun AttributeSchema.basicType(
        kotlinType: String,
        delegateName: String,
        imports: MutableSet<String>,
        attribute: AttributeSchema,
    ): TypeInfo {
        val nullable = attribute.allowNone || attribute.default is JsonNull
        val typeName = if (nullable) "$kotlinType?" else kotlinType
        val defaultValue = defaultValueForType(typeName, attribute.default)
        return if (nullable) {
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType")
            imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.primitive.${kotlinType.toPrimitiveTypeName()}")
            val propertyTypeExpr = "NullableType(${kotlinType.toPrimitiveTypeName()})"
            val delegate = "prop(\"${attribute.name}\", $propertyTypeExpr, $defaultValue)"
            TypeInfo(typeName, delegate, propertyTypeExpr, defaultValue)
        } else {
            TypeInfo(typeName, "$delegateName(\"${attribute.name}\", $defaultValue)", kotlinType.toPrimitiveTypeName(), defaultValue)
        }
    }

    private fun AttributeSchema.toEnumType(
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): TypeInfo {
        val enumName = "${widgetInfo.className}${name.toPascalCase()}Enum"
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnum")
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnumEntry")
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnumType")

        val entries = enum.map { value ->
            "    public val ${value.toPascalCase()}: WidgetEnumEntry<$enumName> by entry(\"$value\")"
        }.joinToString("\n")

        val enumDeclaration = "public object $enumName : WidgetEnum<$enumName>() {\n$entries\n}"
        helperDeclarations += enumDeclaration

        val defaultEntry = (default as? JsonPrimitive)?.content
        val nullable = allowNone || default is JsonNull
        val defaultExpression = when {
            defaultEntry == null -> "null"
            else -> "$enumName.${defaultEntry.toPascalCase()}"
        }

        val typeDefaultEntry = defaultEntry ?: enum.first()
        imports.add("org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType")
        val typeExpr = if (nullable) {
            "NullableType(WidgetEnumType($enumName, ${enumName}.${typeDefaultEntry.toPascalCase()}))"
        } else {
            "WidgetEnumType($enumName, ${enumName}.${typeDefaultEntry.toPascalCase()})"
        }

        val kotlinType = if (nullable) "WidgetEnumEntry<$enumName>?" else "WidgetEnumEntry<$enumName>"
        val delegate = "prop(\"$name\", $typeExpr, $defaultExpression)"
        return TypeInfo(kotlinType, delegate, typeExpr, defaultExpression)
    }

    private fun AttributeSchema.referencedClassName(): String {
        val base = widget ?: error("Reference widget is not specified")
        if (base == "Widget") return "WidgetModel"
        return if (base.endsWith("Widget")) base else "${base}Widget"
    }

    private fun defaultValueForType(kotlinType: String, value: JsonElement): String = when {
        value is JsonNull -> "null"
        kotlinType == "ByteArray" || kotlinType == "ByteArray?" -> "byteArrayOf()"
        value is JsonPrimitive && value.isString -> "\"${value.content.replace("\\", "\\\\").replace("\"", "\\\"")}\""
        value is JsonPrimitive && value.safeBoolean != null -> value.safeBoolean.toString()
        value is JsonPrimitive && value.safeInt != null -> value.safeInt.toString()
        value is JsonPrimitive && value.safeDouble != null -> value.safeDouble.toString()
        else -> error("Unsupported default value for type $kotlinType: $value")
    }

    private fun defaultArrayValue(
        elementKotlinType: String,
        nullableElementType: String,
        value: JsonElement,
    ): String =
        if (value is kotlinx.serialization.json.JsonArray && value.isNotEmpty()) {
            val renderedItems = value.joinToString(", ") { renderLiteral(elementKotlinType, nullableElementType, it) }
            "listOf($renderedItems)"
        } else {
            "emptyList()"
        }

    private fun renderLiteral(elementKotlinType: String, nullableElementType: String, value: JsonElement): String = when {
        value is JsonNull -> "null"
        value is JsonPrimitive && value.isString -> "\"${value.content.replace("\\", "\\\\").replace("\"", "\\\"")}\""
        value is JsonPrimitive && value.safeBoolean != null -> value.safeBoolean.toString()
        value is JsonPrimitive && value.safeInt != null -> value.safeInt.toString()
        value is JsonPrimitive && value.safeDouble != null -> value.safeDouble.toString()
        else -> error("Unsupported array literal for $elementKotlinType/$nullableElementType: $value")
    }

    private val JsonPrimitive.safeInt: Int? get() = runCatching { int }.getOrNull()
    private val JsonPrimitive.safeDouble: Double? get() = runCatching { double }.getOrNull()
    private val JsonPrimitive.safeBoolean: Boolean? get() = runCatching { boolean }.getOrNull()

    private fun String.toPrimitiveTypeName(): String = when (this) {
        "Int" -> "IntType"
        "Double" -> "FloatType"
        "Boolean" -> "BooleanType"
        "String" -> "StringType"
        "ByteArray" -> "BytesType"
        else -> error("Unsupported primitive type $this")
    }

    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "org.jetbrains.kotlinx.jupyter.widget.library.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val content = buildString {
            appendLine(GENERATED_NOTICE)
            appendLine("package $packageName")
            appendLine()
            appendLine("import org.jetbrains.kotlinx.jupyter.widget.library.*")
            appendLine("import org.jetbrains.kotlinx.jupyter.widget.model.WidgetFactory")
            appendLine()
            appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
            widgetInfos.sortedBy { it.className }.forEach { info ->
                appendLine("    ${info.className}.Factory,")
            }
            appendLine(")")
        }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "org.jetbrains.kotlinx.jupyter.widget.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val content = buildString {
            appendLine(GENERATED_NOTICE)
            appendLine("package $packageName")
            appendLine()
            appendLine("import org.jetbrains.kotlinx.jupyter.widget.integration.globalWidgetManager")
            appendLine("import org.jetbrains.kotlinx.jupyter.widget.library.*")
            appendLine()
            widgetInfos.sortedBy { it.className }.forEach { info ->
                appendLine("public fun ${info.functionName}Widget(): ${info.className} = globalWidgetManager.${info.functionName}()")
                appendLine()
            }
        }

        filePath.writeText(content)
    }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files.walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val baseName: String,
    val className: String,
    val functionName: String,
    val schema: WidgetSchema,
)

private fun String.toCamelCase(): String {
    if (isEmpty()) return this
    if (length == 1) return lowercase()
    var index = 1
    while (index < length && this[index].isUpperCase()) {
        index++
    }
    val prefix = substring(0, index)
    val rest = substring(index)
    return prefix.lowercase() + rest
}

private fun String.toPascalCase(): String = split('_', '-', ' ').joinToString("") { part ->
    part.lowercase().replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
}

private data class TypeInfo(
    val kotlinType: String,
    val delegate: String,
    val propertyTypeExpr: String,
    val defaultValue: String,
) {
    val kotlinTypeWithoutNullability: String get() = kotlinType.removeSuffix("?")
}
