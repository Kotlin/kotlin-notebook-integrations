package org.jetbrains.kotlinx.jupyter.widget.generator

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

private val hiddenAttributeNames =
    setOf(
        "_model_name",
        "_model_module",
        "_model_module_version",
        "_view_name",
        "_view_module",
        "_view_module_version",
    )

private data class TraitInfo(
    val baseClassName: String,
    val traitProperties: Map<String, String?>,
    val import: String? = null,
)

private data class OptionWidgetTraitInfo(
    val baseClassName: String,
    val indexType: String,
)

private fun OptionWidgetTraitInfo.toTraitInfo(): TraitInfo =
    TraitInfo(
        baseClassName = baseClassName,
        traitProperties =
            mapOf(
                "_options_labels" to "List<String>",
                "index" to indexType,
            ),
        import = "$WIDGETS_PACKAGE.library.options.$baseClassName",
    )

private val traits: List<TraitInfo> =
    listOf(
        OptionWidgetTraitInfo(
            baseClassName = "SingleNullableSelectionWidgetBase",
            indexType = "Int?",
        ),
        OptionWidgetTraitInfo(
            baseClassName = "SingleSelectionWidgetBase",
            indexType = "Int",
        ),
        OptionWidgetTraitInfo(
            baseClassName = "MultipleSelectionWidgetBase",
            indexType = "List<Int>",
        ),
        OptionWidgetTraitInfo(
            baseClassName = "SelectionRangeWidgetBase",
            indexType = "IntRange?",
        ),
    ).map { it.toTraitInfo() }

private val baseWidgets = setOf("OutputWidget")

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String?,
    val version: String,
)

public fun main() {
    val projectRoot =
        Path
            .of(".")
            .toAbsolutePath()
            .normalize()
            .parent
            ?.parent
            ?.parent
            ?: error("Unable to resolve project root")

    val generator = WidgetGenerator(projectRoot)
    generator.generate()
}

private class WidgetGenerator(
    projectRoot: Path,
) {
    private val json = Json { ignoreUnknownKeys = true }

    private val schemaPath = projectRoot / "integrations/widgets/widgets-generator/schema.json"
    private val apiOutput = projectRoot / "integrations/widgets/widgets-api/src/generated/kotlin"
    private val jupyterOutput = projectRoot / "integrations/widgets/widgets-jupyter/src/generated/kotlin"
    private val enums = mutableMapOf<String, EnumInfo>()

    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        for (widgetInfo in widgetInfos) {
            generateWidgetFile(widgetInfo)
        }
        generateEnumFiles()
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName =
            model.name?.removeSuffix("Model")
                ?: view.name?.removeSuffix("View")
                ?: error("Either model or view name must be specified")
        val classNamePrefix = if (baseName.endsWith("Widget")) baseName else "${baseName}Widget"

        val isBaseWidget = classNamePrefix in baseWidgets
        val className = if (isBaseWidget) "${classNamePrefix}Base" else classNamePrefix

        val functionName = baseName.toCamelCase()
        return WidgetInfo(baseName, className, functionName, isBaseWidget, this)
    }

    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "$WIDGETS_PACKAGE.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val attributeProperties =
            info.schema.attributes.associate {
                it.name to it.toPropertyType(json, enums, info.className)
            }
        val trait =
            traits.find { trait ->
                trait.traitProperties.all { (name, type) ->
                    val attrType = attributeProperties[name] ?: return@all false
                    type == null || attrType.kotlinType == type
                }
            }

        val imports =
            sortedSetOf<String>().apply {
                for (importName in listOf(
                    "WidgetManager",
                    "model.DefaultWidgetFactory",
                    "model.DefaultWidgetModel",
                    "model.WidgetSpec",
                    "model.createAndRegisterWidget",
                )) {
                    add("$WIDGETS_PACKAGE.$importName")
                }
            }

        val helperDeclarations = mutableListOf<String>()
        val properties =
            info.schema.attributes.mapNotNull { attribute ->
                if (attribute.name in hiddenAttributeNames) return@mapNotNull null
                if (trait != null && attribute.name in trait.traitProperties) return@mapNotNull null
                val propertyType = attributeProperties[attribute.name]!!
                createProperty(attribute, propertyType, helperDeclarations, imports)
            }

        val specName = "${info.functionName}Spec"
        val specVisibility = if (info.isBaseWidget) "internal" else "private"
        val spec =
            buildString {
                appendLine("$specVisibility val $specName = WidgetSpec(")

                fun addArgument(
                    name: String,
                    value: String?,
                ) {
                    appendLine("    $name = ${value?.let { "\"$it\"" } ?: "null"},")
                }

                addArgument("modelName", info.schema.model.name)
                addArgument("modelModule", info.schema.model.module)
                addArgument("modelModuleVersion", info.schema.model.version)
                addArgument("viewName", info.schema.view.name)
                addArgument("viewModule", info.schema.view.module)
                addArgument("viewModuleVersion", info.schema.view.version)
                appendLine(")")
                appendLine()

                if (!info.isBaseWidget) {
                    appendLine(
                        "public fun WidgetManager.${info.functionName}" +
                            "(setup: ${info.className}.() -> Unit = {}): ${info.className} =\n" +
                            "    createAndRegisterWidget(${info.className}.Factory).apply(setup)\n",
                    )
                }
            }

        val body =
            buildString {
                val abstractModifier = if (info.isBaseWidget) "abstract " else ""
                val superClassName = trait?.baseClassName ?: "DefaultWidgetModel"
                if (trait?.import != null) {
                    imports.add(trait.import)
                }

                appendLine("public ${abstractModifier}class ${info.className} internal constructor(")
                appendLine("    widgetManager: WidgetManager,")
                appendLine("    fromFrontend: Boolean,")
                appendLine(") : $superClassName($specName, widgetManager) {")
                if (!info.isBaseWidget) {
                    appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
                }
                appendLine()

                for (property in properties) {
                    appendLine(property)
                }

                appendLine("}")
            }

        val header =
            buildString {
                addHeader(packageName)
                if (imports.isNotEmpty()) {
                    for (import in imports) {
                        appendLine("import $import")
                    }
                    appendLine()
                }

                for (declaration in helperDeclarations) {
                    appendLine(declaration)
                    appendLine()
                }
            }

        filePath.writeText(header + spec + body)
    }

    private fun createProperty(
        attribute: AttributeSchema,
        propertyType: PropertyType,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): String {
        imports.addAll(propertyType.imports)
        helperDeclarations.addAll(propertyType.helperDeclarations)

        val propertyName = attribute.name.toPascalCase().toCamelCase()
        val kotlinType = propertyType.kotlinType
        val defaultValueExpression = propertyType.getDefaultValueExpression(attribute.default)

        val delegateName = propertyType.delegateName ?: "prop"
        val typeExpressionArgument = if (propertyType.delegateName == null) ", " + propertyType.typeExpression else ""
        val delegateCall = "$delegateName(\"${attribute.name}\"$typeExpressionArgument, $defaultValueExpression)"

        return buildString {
            val help = attribute.help
            if (help.isNotEmpty()) {
                appendLine("    /** $help */")
            }
            append("    public var $propertyName: $kotlinType by $delegateCall")
        }
    }

    private fun generateEnumFiles() {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.enums"
        val directory = apiOutput / packageName.replace('.', '/')
        directory.createDirectories()

        for (enumInfo in enums.values) {
            val filePath = directory / "${enumInfo.className}.kt"
            val builder = StringBuilder()
            builder.addHeader(packageName)
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnum")
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")
            builder.appendLine()

            val entries =
                enumInfo.values.joinToString("\n") { value ->
                    val entryName = if (value.isEmpty()) "Default" else value.toPascalCase()
                    "    public val $entryName: WidgetEnumEntry<${enumInfo.className}> by entry(\"$value\")"
                }

            builder.appendLine("public object ${enumInfo.className} : WidgetEnum<${enumInfo.className}>() {")
            builder.appendLine(entries)
            builder.appendLine("}")

            filePath.writeText(builder.toString())
        }
    }

    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val registryInfos = widgetInfos.filter { !it.isBaseWidget }
        val sortedInfos = registryInfos.sortedInImportsOrder { it.className }
        val content =
            buildString {
                addHeader(packageName)
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                appendLine("import $WIDGETS_PACKAGE.model.WidgetFactory")
                appendLine()
                appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
                for (info in sortedInfos) {
                    appendLine("    ${info.className}.Factory,")
                }
                appendLine(")")
            }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGETS_PACKAGE.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val helperInfos = widgetInfos.filter { !it.isBaseWidget }
        val sortedInfos = helperInfos.sortedInImportsOrder { it.functionName }
        val content =
            buildString {
                addHeader(packageName)
                for (info in helperInfos.sortedInImportsOrder { it.className }) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.functionName}")
                }
                appendLine()
                for (info in sortedInfos) {
                    val functionName = info.functionName.removeSuffix("Widget") + "Widget"
                    appendLine(
                        "public fun $functionName(setup: ${info.className}.() -> Unit = {}): ${info.className} = globalWidgetManager.${info.functionName}(setup)",
                    )
                    appendLine()
                }
            }

        filePath.writeText(content)
    }

    private fun StringBuilder.addHeader(packageName: String) {
        appendLine(GENERATED_NOTICE)
        appendLine("package $packageName")
        appendLine()
    }

    private fun <T> List<T>.sortedInImportsOrder(representAsString: (T) -> String): List<T> =
        sortedWith { a, b ->
            when {
                representAsString(a).startsWith(representAsString(b)) -> 1
                representAsString(b).startsWith(representAsString(a)) -> -1
                else -> representAsString(a).compareTo(representAsString(b))
            }
        }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files
                .walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val baseName: String,
    val className: String,
    val functionName: String,
    val isBaseWidget: Boolean,
    val schema: WidgetSchema,
)
