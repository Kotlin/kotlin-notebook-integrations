package org.jetbrains.kotlinx.jupyter.widget.generator

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

private val hiddenAttributeNames =
    setOf(
        "_model_name",
        "_model_module",
        "_model_module_version",
        "_view_name",
        "_view_module",
        "_view_module_version",
    )

private val baseWidgets = setOf("OutputWidget")

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String?,
    val version: String,
)

/**
 * Main entry point for the widget generator.
 */
public fun main(args: Array<String>) {
    val schemaPath = Path.of(args[0])
    val apiOutput = Path.of(args[1])
    val jupyterOutput = Path.of(args[2])

    val generator = WidgetGenerator(schemaPath, apiOutput, jupyterOutput)
    generator.generate()
}

/**
 * Handles the generation of Kotlin widget models from a JSON schema.
 * It produces:
 * 1. Widget classes with property delegation for state sync.
 * 2. Enum objects for widget-specific enums.
 * 3. A registry of all default widget factories.
 * 4. Global helper functions for widget creation in Jupyter notebooks.
 */
private class WidgetGenerator(
    private val schemaPath: Path,
    private val apiOutput: Path,
    private val jupyterOutput: Path,
) {
    private val json = Json { ignoreUnknownKeys = true }
    private val enums = mutableMapOf<String, EnumInfo>()

    /**
     * Executes the generation process.
     */
    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        for (widgetInfo in widgetInfos) {
            generateWidgetFile(widgetInfo)
        }
        generateEnumFiles()
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName =
            model.name?.removeSuffix("Model")
                ?: view.name?.removeSuffix("View")
                ?: error("Either model or view name must be specified")
        val classNamePrefix = baseName.toWidgetClassName()

        val isBaseWidget = classNamePrefix in baseWidgets
        val className = if (isBaseWidget) "${classNamePrefix}Base" else classNamePrefix

        val functionName = baseName.toCamelCase()
        return WidgetInfo(className, functionName, isBaseWidget, this)
    }

    /**
     * Generates a single Kotlin file for a widget class.
     */
    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "$WIDGETS_PACKAGE.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val attributeProperties =
            info.schema.attributes.associate {
                it.name to it.toPropertyType(json, enums, info.className)
            }
        val matchedTraits = findMatchedTraits(info.className, attributeProperties)
        val baseClassTrait = findBaseClassTrait(matchedTraits, info.className)
        val interfaceTraits = matchedTraits.filter { it.isInterface }

        val imports =
            sortedSetOf<String>().apply {
                for (importName in listOf(
                    "WidgetManager",
                    "model.DefaultWidgetFactory",
                    "model.DefaultWidgetModel",
                    "model.WidgetSpec",
                    "model.createAndRegisterWidget",
                )) {
                    add("$WIDGETS_PACKAGE.$importName")
                }
            }

        val helperDeclarations = mutableListOf<String>()
        val properties =
            info.schema.attributes.mapNotNull { attribute ->
                if (attribute.name in hiddenAttributeNames) return@mapNotNull null
                val trait = matchedTraits.find { attribute.name in it.traitProperties }
                val propertyType = attributeProperties[attribute.name]!!

                if (trait != null && trait.skipGeneration) return@mapNotNull null

                val shouldOverride = trait != null && trait.shouldOverride
                createProperty(attribute, propertyType, helperDeclarations, imports, isOverride = shouldOverride)
            }

        val specName = "${info.functionName}Spec"
        val specVisibility = if (info.isBaseWidget) "internal" else "private"
        val spec =
            buildString {
                appendLine("$specVisibility val $specName = WidgetSpec(")

                fun addArgument(
                    name: String,
                    value: String?,
                ) {
                    appendLine("    $name = ${value?.let { "\"$it\"" } ?: "null"},")
                }

                addArgument("modelName", info.schema.model.name)
                addArgument("modelModule", info.schema.model.module)
                addArgument("modelModuleVersion", info.schema.model.version)
                addArgument("viewName", info.schema.view.name)
                addArgument("viewModule", info.schema.view.module)
                addArgument("viewModuleVersion", info.schema.view.version)
                appendLine(")")
                appendLine()

                if (!info.isBaseWidget) {
                    appendLine(
                        "public fun WidgetManager.${info.functionName}" +
                            "(setup: ${info.className}.() -> Unit = {}): ${info.className} =\n" +
                            "    createAndRegisterWidget(${info.className}.Factory).apply(setup)\n",
                    )
                }
            }

        val body =
            buildString {
                val abstractModifier = if (info.isBaseWidget) "abstract " else ""
                val superClassName = baseClassTrait?.baseClassName ?: "DefaultWidgetModel"
                val extraConstructorParams = if (superClassName != "DefaultWidgetModel") ", fromFrontend" else ""

                for (trait in matchedTraits) {
                    trait.import?.let { imports.add(it) }
                }

                val traitSuffix =
                    buildString {
                        append(" : $superClassName($specName, widgetManager$extraConstructorParams)")
                        for (interfaceTrait in interfaceTraits) {
                            append(", ${interfaceTrait.baseClassName}")
                        }
                    }

                appendLine("public ${abstractModifier}class ${info.className} internal constructor(")
                appendLine("    widgetManager: WidgetManager,")
                appendLine("    fromFrontend: Boolean,")
                appendLine(")$traitSuffix {")
                if (!info.isBaseWidget) {
                    appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
                }

                for (property in properties) {
                    appendLine(property)
                }

                appendLine("}")
            }

        val header =
            buildString {
                addHeader(packageName)
                if (imports.isNotEmpty()) {
                    for (import in imports) {
                        appendLine("import $import")
                    }
                    appendLine()
                }

                for (declaration in helperDeclarations) {
                    appendLine(declaration)
                    appendLine()
                }
            }

        filePath.writeText(header + spec + body)
    }

    /**
     * Creates a property declaration string for a widget attribute.
     */
    private fun createProperty(
        attribute: AttributeSchema,
        propertyType: PropertyType,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
        isOverride: Boolean = false,
    ): String {
        imports.addAll(propertyType.imports)
        helperDeclarations.addAll(propertyType.helperDeclarations)

        val propertyName = attribute.name.toCamelCase()
        val kotlinType = propertyType.kotlinType
        val defaultValueExpression = propertyType.getDefaultValueExpression(attribute.default)

        val delegateName = propertyType.delegateName ?: "prop"
        val typeExpressionArgument = if (propertyType.delegateName == null) ", " + propertyType.typeExpression else ""
        val delegateCall = "$delegateName(\"${attribute.name}\"$typeExpressionArgument, $defaultValueExpression)"

        return buildString {
            val help = attribute.help
            if (help.isNotEmpty()) {
                appendLine()
                appendLine("    /**")
                appendLine("     * $help")
                appendLine("     */")
            }
            val modifier = if (isOverride) "override " else ""
            append("    public ${modifier}var $propertyName: $kotlinType by $delegateCall")
        }
    }

    private fun generateEnumFiles() {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.enums"
        val directory = apiOutput / packageName.replace('.', '/')
        directory.createDirectories()

        for (enumInfo in enums.values) {
            val filePath = directory / "${enumInfo.className}.kt"
            val builder = StringBuilder()
            builder.addHeader(packageName)
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnum")
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")
            builder.appendLine()

            val entries =
                enumInfo.values.joinToString("\n") { value ->
                    val entryName = if (value.isEmpty()) "Default" else value.toPascalCase()
                    "    public val $entryName: WidgetEnumEntry<${enumInfo.className}> by entry(\"$value\")"
                }

            builder.appendLine("public object ${enumInfo.className} : WidgetEnum<${enumInfo.className}>() {")
            builder.appendLine(entries)
            builder.appendLine("}")

            filePath.writeText(builder.toString())
        }
    }

    /**
     * Generates `DefaultWidgetFactories.kt` with a list of all registered widget factories.
     */
    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val registryInfos = widgetInfos.filter { !it.isBaseWidget }
        val sortedInfos = registryInfos.sortedInImportsOrder { it.className }
        val content =
            buildString {
                addHeader(packageName)
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                appendLine("import $WIDGETS_PACKAGE.model.WidgetFactory")
                appendLine()
                appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
                for (info in sortedInfos) {
                    appendLine("    ${info.className}.Factory,")
                }
                appendLine(")")
            }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGETS_PACKAGE.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val helperInfos = widgetInfos.filter { !it.isBaseWidget }
        val sortedInfos = helperInfos.sortedInImportsOrder { it.functionName }
        val content =
            buildString {
                addHeader(packageName)
                for (info in helperInfos.sortedInImportsOrder { it.className }) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.functionName}")
                }
                appendLine()
                for (info in sortedInfos) {
                    val functionName = info.functionName.removeSuffix("Widget") + "Widget"
                    appendLine(
                        "public fun $functionName(setup: ${info.className}.() -> Unit = {}): ${info.className} = globalWidgetManager.${info.functionName}(setup)",
                    )
                    appendLine()
                }
            }

        filePath.writeText(content)
    }

    private fun StringBuilder.addHeader(packageName: String) {
        appendLine(GENERATED_NOTICE)
        appendLine("package $packageName")
        appendLine()
    }

    private fun <T> List<T>.sortedInImportsOrder(representAsString: (T) -> String): List<T> =
        sortedWith { a, b ->
            when {
                representAsString(a).startsWith(representAsString(b)) -> 1
                representAsString(b).startsWith(representAsString(a)) -> -1
                else -> representAsString(a).compareTo(representAsString(b))
            }
        }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files
                .walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val className: String,
    val functionName: String,
    val isBaseWidget: Boolean,
    val schema: WidgetSchema,
)
