package org.jetbrains.kotlinx.jupyter.widget.generator

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.doubleOrNull
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.json.intOrNull
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

private const val WIDGETS_PACKAGE = "org.jetbrains.kotlinx.jupyter.widget"
private const val WIDGET_TYPES_PACKAGE = "$WIDGETS_PACKAGE.model.types"
private const val WIDGET_LIBRARY_PACKAGE = "$WIDGETS_PACKAGE.library"

private val hiddenAttributeNames =
    setOf(
        "_model_name",
        "_model_module",
        "_model_module_version",
        "_view_name",
        "_view_module",
        "_view_module_version",
    )

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String?,
    val version: String,
)

@Serializable
private data class AttributeSchema(
    val name: String,
    val type: AttributeType,
    val default: JsonElement,
    @SerialName("allow_none") val allowNone: Boolean = false,
    val enum: List<String> = emptyList(),
    val help: String = "",
    val items: AttributeItems? = null,
    val widget: String? = null,
    @SerialName("union_attributes") val unionAttributes: List<JsonObject> = emptyList(),
)

@Serializable
private data class AttributeItems(
    val type: AttributeType,
    val widget: String? = null,
)

private object AttributeTypeSerializer {
    fun serialize(type: AttributeType): JsonElement =
        when (type) {
            is AttributeType.Single -> JsonPrimitive(type.name)
            is AttributeType.Union -> Json.encodeToJsonElement(type.options.map { serialize(it) })
        }
}

@Serializable(with = AttributeType.Companion::class)
private sealed class AttributeType {
    data class Single(
        val name: String,
    ) : AttributeType()

    data class Union(
        val options: List<Single>,
    ) : AttributeType()

    companion object : kotlinx.serialization.KSerializer<AttributeType> {
        private val delegate = JsonElement.serializer()

        override val descriptor = delegate.descriptor

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder): AttributeType =
            when (val element = delegate.deserialize(decoder)) {
                is JsonPrimitive -> Single(element.content)
                else -> {
                    val options = Json.decodeFromJsonElement<List<JsonPrimitive>>(element)
                    Union(options.map { Single(it.content) })
                }
            }

        override fun serialize(
            encoder: kotlinx.serialization.encoding.Encoder,
            value: AttributeType,
        ) {
            encoder.encodeSerializableValue(delegate, AttributeTypeSerializer.serialize(value))
        }
    }
}

public fun main() {
    val projectRoot =
        Path
            .of(".")
            .toAbsolutePath()
            .normalize()
            .parent
            ?.parent
            ?.parent
            ?: error("Unable to resolve project root")

    val generator = WidgetGenerator(projectRoot)
    generator.generate()
}

private class WidgetGenerator(
    projectRoot: Path,
) {
    private val json = Json { ignoreUnknownKeys = true }

    private val schemaPath = projectRoot / "integrations/widgets/widgets-generator/schema.json"
    private val apiOutput = projectRoot / "integrations/widgets/widgets-api/src/generated/kotlin"
    private val jupyterOutput = projectRoot / "integrations/widgets/widgets-jupyter/src/generated/kotlin"
    private val enums = mutableMapOf<String, EnumInfo>()

    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        for (widgetInfo in widgetInfos) {
            generateWidgetFile(widgetInfo)
        }
        generateEnumFiles()
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName =
            model.name?.removeSuffix("Model")
                ?: view.name?.removeSuffix("View")
                ?: error("Either model or view name must be specified")
        val className = if (baseName.endsWith("Widget")) baseName else "${baseName}Widget"
        val functionName = baseName.toCamelCase()
        return WidgetInfo(baseName, className, functionName, this)
    }

    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "$WIDGETS_PACKAGE.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val builder = StringBuilder()
        val imports =
            sortedSetOf<String>().apply {
                for (importName in listOf(
                    "WidgetManager",
                    "model.DefaultWidgetFactory",
                    "model.DefaultWidgetModel",
                    "model.WidgetSpec",
                    "model.createAndRegisterWidget",
                )) {
                    add("$WIDGETS_PACKAGE.$importName")
                }
            }

        val helperDeclarations = mutableListOf<String>()
        val properties =
            info.schema.attributes.mapNotNull { attribute ->
                if (attribute.name in hiddenAttributeNames) return@mapNotNull null
                createProperty(attribute, info, helperDeclarations, imports)
            }

        builder.addHeader(packageName)
        if (imports.isNotEmpty()) {
            for (import in imports) {
                builder.appendLine("import $import")
            }
            builder.appendLine()
        }

        for (declaration in helperDeclarations) {
            builder.appendLine(declaration)
            builder.appendLine()
        }

        val specName = "${info.functionName}Spec"
        builder.appendLine("private val $specName = WidgetSpec(")
        builder.appendLine("    modelName = \"${info.schema.model.name}\",")
        builder.appendLine("    modelModule = \"${info.schema.model.module}\",")
        builder.appendLine("    modelModuleVersion = \"${info.schema.model.version}\",")
        builder.appendLine("    viewName = \"${info.schema.view.name}\",")
        builder.appendLine("    viewModule = \"${info.schema.view.module}\",")
        builder.appendLine("    viewModuleVersion = \"${info.schema.view.version}\",")
        builder.appendLine(")")
        builder.appendLine()

        builder.appendLine(
            "public fun WidgetManager.${info.functionName}(): ${info.className} = createAndRegisterWidget(${info.className}.Factory)",
        )
        builder.appendLine()
        builder.appendLine("public class ${info.className} internal constructor(")
        builder.appendLine("    widgetManager: WidgetManager,")
        builder.appendLine(") : DefaultWidgetModel($specName, widgetManager) {")
        builder.appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
        builder.appendLine()

        for (property in properties) {
            builder.appendLine(property)
        }

        builder.appendLine("}")

        filePath.writeText(builder.toString())
    }

    private fun createProperty(
        attribute: AttributeSchema,
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): String {
        val context = GenerationContext(widgetInfo, helperDeclarations, imports)
        val typeInfo = attribute.toTypeInfo(context)
        return buildString {
            val help = attribute.help
            if (help.isNotEmpty()) {
                appendLine("    /** $help */")
            }
            append("    public var ${attribute.name.toPascalCase().toCamelCase()}: ${typeInfo.kotlinType} by ")
            append(typeInfo.delegate)
        }
    }

    private data class GenerationContext(
        val widgetInfo: WidgetInfo,
        val helperDeclarations: MutableList<String>,
        val imports: MutableSet<String>,
    )

    private val AttributeSchema.isNullable: Boolean get() = allowNone || default is JsonNull

    private fun AttributeSchema.toNullableTypeExpr(
        typeExpr: String,
        imports: MutableSet<String>,
    ): String =
        if (isNullable && typeExpr != "AnyType") {
            imports.add("$WIDGET_TYPES_PACKAGE.compound.NullableType")
            "NullableType($typeExpr)"
        } else {
            typeExpr
        }

    private fun AttributeSchema.toNullableKotlinType(baseType: String): String = if (isNullable) "$baseType?" else baseType

    private fun AttributeSchema.toTypeInfo(context: GenerationContext): TypeInfo =
        when (type) {
            is AttributeType.Single -> toSingleTypeInfo(context)
            is AttributeType.Union -> toUnionTypeInfo(context)
        }

    private fun AttributeSchema.toUnionTypeInfo(context: GenerationContext): TypeInfo {
        val nameForType = "${context.widgetInfo.className}${name.toPascalCase()}UnionType"
        val optionSchemas =
            if (unionAttributes.isNotEmpty()) {
                unionAttributes.map { json.decodeFromJsonElement<AttributeSchema>(it.addMissingFields(this)) }
            } else {
                when (val t = type) {
                    is AttributeType.Single -> listOf(this.copy(type = t))
                    is AttributeType.Union ->
                        t.options.map { opt ->
                            this.copy(type = opt)
                        }
                }
            }

        val candidateInfos =
            optionSchemas.map { candidate ->
                candidate.toSingleTypeInfo(context)
            }

        val serializerSelector =
            buildString {
                append(
                    """
                    |{ value ->
                    |        when (value) {
                    |
                    """.trimMargin(),
                )
                append(
                    candidateInfos.joinToString(separator = "\n") { info ->
                        val checkType =
                            info.kotlinTypeWithoutNullability.let {
                                if (it.contains("<")) it.replace(Regex("<.*>"), "<*>") else it
                            }
                        "   |            is $checkType -> ${info.propertyTypeExpr}".trimMargin()
                    },
                )
                append(
                    """
                    |
                    |            else -> 
                    """.trimMargin(),
                )
                append(candidateInfos.last().propertyTypeExpr)
                append(
                    """
                    |
                    |        }
                    |    }
                    """.trimMargin(),
                )
            }

        context.imports.add("$WIDGET_TYPES_PACKAGE.compound.UnionType")
        val deserializers =
            candidateInfos.joinToString(", ") {
                it.propertyTypeExpr
            }
        val unionDeclaration =
            buildString {
                appendLine("private val $nameForType = UnionType<Any>(")
                appendLine("    name = \"$name\",")
                appendLine("    default = ${candidateInfos.first().defaultValue},")
                appendLine("    serializerSelector = $serializerSelector,")
                appendLine("    deserializers = listOf($deserializers),")
                appendLine(")")
            }

        context.helperDeclarations += unionDeclaration

        val defaultValue = candidateInfos.first().defaultValue
        return getTypeInfo(context, "Any", nameForType, defaultValue)
    }

    private fun JsonObject.addMissingFields(base: AttributeSchema): JsonObject {
        val newMap = toMutableMap()
        if ("name" !in newMap) newMap["name"] = JsonPrimitive(base.name)
        if ("default" !in newMap) newMap["default"] = base.default
        if ("help" !in newMap) newMap["help"] = JsonPrimitive(base.help)
        return JsonObject(newMap)
    }

    private fun AttributeSchema.toSingleTypeInfo(context: GenerationContext): TypeInfo {
        if (enum.isNotEmpty()) {
            return toEnumType(context)
        }

        return when (val t = type) {
            is AttributeType.Single ->
                when (t.name) {
                    "string" -> basicType(context, "String", "$WIDGET_TYPES_PACKAGE.primitive.StringType", "stringProp")
                    "bool" -> basicType(context, "Boolean", "$WIDGET_TYPES_PACKAGE.primitive.BooleanType", "boolProp")
                    "int" -> basicType(context, "Int", "$WIDGET_TYPES_PACKAGE.primitive.IntType", "intProp")
                    "float" -> basicType(context, "Double", "$WIDGET_TYPES_PACKAGE.primitive.FloatType", "doubleProp")
                    "bytes" -> basicType(context, "ByteArray", "$WIDGET_TYPES_PACKAGE.primitive.BytesType", "bytesProp")
                    "any" -> basicType(context, "Any", "$WIDGET_TYPES_PACKAGE.primitive.AnyType")
                    "Datetime" -> basicType(context, "java.time.Instant", "$WIDGET_TYPES_PACKAGE.datetime.DatetimeType")
                    "Date" -> basicType(context, "java.time.LocalDate", "$WIDGET_TYPES_PACKAGE.datetime.DateType")
                    "Time" -> basicType(context, "java.time.LocalTime", "$WIDGET_TYPES_PACKAGE.datetime.TimeType")
                    "reference" -> referenceType(context)
                    "object" -> basicType(context, "Map<String, Any?>", "$WIDGET_TYPES_PACKAGE.compound.RawObjectType")
                    "array" -> arrayType(context)
                    else -> error("Unsupported type $type")
                }
            else -> error("Expected Single type, but got $type")
        }
    }

    private fun AttributeSchema.referenceType(context: GenerationContext): TypeInfo {
        val targetClass = referencedClassName()
        val defaultValue =
            if ((default as? JsonPrimitive)?.content == "reference to new instance") {
                "widgetManager.${targetClass.toCamelCase().removeSuffix("Widget")}()"
            } else {
                "null"
            }

        if (targetClass == "WidgetModel") {
            context.imports.add("$WIDGETS_PACKAGE.model.WidgetModel")
        }

        val propertyTypeExpr = "$WIDGET_TYPES_PACKAGE.widget.WidgetReferenceType<$targetClass>()"
        val kotlinType = toNullableKotlinType(targetClass)
        return getTypeInfo(context, kotlinType, propertyTypeExpr, defaultValue, "widgetProp", "nullableWidgetProp")
    }

    private fun AttributeSchema.arrayType(context: GenerationContext): TypeInfo {
        val actualItems = items ?: AttributeItems(type = AttributeType.Single("any"))
        val elementInfo = actualItems.toElementType(context)
        val kotlinType = toNullableKotlinType("List<${elementInfo.kotlinType}>")
        val baseTypeExpr = "$WIDGET_TYPES_PACKAGE.compound.ArrayType(${elementInfo.propertyTypeExpr})"
        val defaultValue = if (isNullable) "null" else defaultArrayValue(elementInfo.kotlinType, default)
        return getTypeInfo(context, kotlinType, baseTypeExpr, defaultValue)
    }

    private fun AttributeItems.toElementType(context: GenerationContext): TypeInfo {
        val schema = AttributeSchema(name = "item", type = type, default = JsonNull, widget = widget)
        return schema.toSingleTypeInfo(context)
    }

    private fun AttributeSchema.basicType(
        context: GenerationContext,
        kotlinType: String,
        jupyterType: String,
        delegateName: String? = null,
        nullableDelegateName: String? = null,
    ): TypeInfo {
        val actualKotlinType = toNullableKotlinType(kotlinType)
        val defaultValue = renderLiteral(actualKotlinType, default)

        return getTypeInfo(context, actualKotlinType, jupyterType, defaultValue, delegateName, nullableDelegateName)
    }

    private fun AttributeSchema.getTypeInfo(
        context: GenerationContext,
        kotlinType: String,
        jupyterType: String,
        defaultValue: String,
        delegateName: String? = null,
        nullableDelegateName: String? = null,
    ): TypeInfo {
        val typeExpr =
            if ('.' in jupyterType) {
                val fqnEnd = jupyterType.findAnyOf(listOf("(", "<"))?.first ?: jupyterType.length
                val fqn = jupyterType.take(fqnEnd)
                context.imports.add(fqn)
                fqn.substringAfterLast('.') + jupyterType.substring(fqnEnd)
            } else {
                jupyterType
            }
        val propertyTypeExpr = toNullableTypeExpr(typeExpr, context.imports)
        val actualDelegateName = if (isNullable) nullableDelegateName else delegateName

        val delegateCall =
            if (actualDelegateName == null) {
                "prop(\"${name}\", $propertyTypeExpr, $defaultValue)"
            } else {
                "$actualDelegateName(\"${name}\", $defaultValue)"
            }

        return TypeInfo(kotlinType, delegateCall, propertyTypeExpr, defaultValue)
    }

    private fun AttributeSchema.toEnumType(context: GenerationContext): TypeInfo {
        val enumName = name.toPascalCase()
        val enumInfo = EnumInfo(enumName, enum)
        val existingEnum = enums[enumName]
        if (existingEnum != null && existingEnum.values != enum) {
            error("Enum conflict for $enumName: existing values ${existingEnum.values}, new values $enum")
        }
        enums[enumName] = enumInfo

        val enumPackage = "$WIDGET_LIBRARY_PACKAGE.enums"
        context.imports.add("$enumPackage.$enumName")
        context.imports.add("$WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")

        val defaultEntry = (default as? JsonPrimitive)?.content?.takeUnless { it == "null" }
        val defaultExpression =
            when {
                defaultEntry == null || defaultEntry !in enum -> "null"
                defaultEntry.isEmpty() -> "$enumName.Default"
                else -> "$enumName.${defaultEntry.toPascalCase()}"
            }

        val typeDefaultEntry = defaultEntry?.takeIf { it in enum } ?: enum.first()
        val typeDefaultEntryName = typeDefaultEntry.ifEmpty { "Default" }
        val baseTypeExpr = "$WIDGET_TYPES_PACKAGE.enums.WidgetEnumType($enumName, $enumName.${typeDefaultEntryName.toPascalCase()})"
        val kotlinType = toNullableKotlinType("WidgetEnumEntry<$enumName>")
        return getTypeInfo(context, kotlinType, baseTypeExpr, defaultExpression)
    }

    private fun AttributeSchema.referencedClassName(): String {
        val base = widget ?: error("Reference widget is not specified")
        if (base == "Widget") return "WidgetModel"
        if (base == "Axis") return "ControllerAxisWidget"
        return if (base.endsWith("Widget")) base else "${base}Widget"
    }

    private fun defaultArrayValue(
        elementKotlinType: String,
        value: JsonElement,
    ): String =
        if (value is kotlinx.serialization.json.JsonArray && value.isNotEmpty()) {
            val renderedItems = value.joinToString(", ") { renderLiteral(elementKotlinType, it) }
            "listOf($renderedItems)"
        } else {
            "emptyList()"
        }

    private fun renderLiteral(
        kotlinType: String,
        value: JsonElement,
    ): String {
        val isNullable = kotlinType.endsWith("?")
        return when {
            value is JsonNull -> "null"
            kotlinType.startsWith("ByteArray") -> "byteArrayOf()"
            kotlinType.startsWith("Map<") -> {
                if (isNullable) "null" else "emptyMap()"
            }
            value is JsonPrimitive -> {
                if (value.isString) {
                    val quoted =
                        value.content
                            .replace("\\", "\\\\")
                            .replace("\"", "\\\"")
                    "\"$quoted\""
                } else {
                    val primitiveValue =
                        value.booleanOrNull
                            ?: value.intOrNull
                            ?: value.doubleOrNull
                            ?: error("Unsupported primitive value for $kotlinType: $value")
                    primitiveValue.toString()
                }
            }
            else -> error("Unsupported literal for $kotlinType: $value")
        }
    }

    private fun generateEnumFiles() {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.enums"
        val directory = apiOutput / packageName.replace('.', '/')
        directory.createDirectories()

        for (enumInfo in enums.values) {
            val filePath = directory / "${enumInfo.className}.kt"
            val builder = StringBuilder()
            builder.addHeader(packageName)
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnum")
            builder.appendLine("import $WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")
            builder.appendLine()

            val entries =
                enumInfo.values.joinToString("\n") { value ->
                    val entryName = if (value.isEmpty()) "Default" else value.toPascalCase()
                    "    public val $entryName: WidgetEnumEntry<${enumInfo.className}> by entry(\"$value\")"
                }

            builder.appendLine("public object ${enumInfo.className} : WidgetEnum<${enumInfo.className}>() {")
            builder.appendLine(entries)
            builder.appendLine("}")

            filePath.writeText(builder.toString())
        }
    }

    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.className }
        val content =
            buildString {
                addHeader(packageName)
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                appendLine("import $WIDGETS_PACKAGE.model.WidgetFactory")
                appendLine()
                appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
                for (info in sortedInfos) {
                    appendLine("    ${info.className}.Factory,")
                }
                appendLine(")")
            }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGETS_PACKAGE.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.functionName }
        val content =
            buildString {
                addHeader(packageName)
                for (info in widgetInfos.sortedInImportsOrder { it.className }) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.functionName}")
                }
                appendLine()
                for (info in sortedInfos) {
                    appendLine("public fun ${info.functionName}Widget(): ${info.className} = globalWidgetManager.${info.functionName}()")
                    appendLine()
                }
            }

        filePath.writeText(content)
    }

    private fun StringBuilder.addHeader(packageName: String) {
        appendLine(GENERATED_NOTICE)
        appendLine("package $packageName")
        appendLine()
    }

    private fun <T> List<T>.sortedInImportsOrder(representAsString: (T) -> String): List<T> =
        sortedWith { a, b ->
            when {
                representAsString(a).startsWith(representAsString(b)) -> 1
                representAsString(b).startsWith(representAsString(a)) -> -1
                else -> representAsString(a).compareTo(representAsString(b))
            }
        }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files
                .walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val baseName: String,
    val className: String,
    val functionName: String,
    val schema: WidgetSchema,
)

private data class EnumInfo(
    val className: String,
    val values: List<String>,
)

private val commonAbbreviations =
    setOf(
        "html",
    )

private fun String.toCamelCase(): String {
    if (isEmpty()) return this
    if (length == 1) return lowercase()
    val abbreviation = commonAbbreviations.find { startsWith(it, ignoreCase = true) }
    val suffixStartIndex =
        if (abbreviation == null) {
            var index = 1
            while (index < length && this[index].isUpperCase()) {
                index++
            }
            index
        } else {
            abbreviation.length
        }

    val prefix = substring(0, suffixStartIndex)
    val rest = substring(suffixStartIndex)
    return prefix.lowercase() + rest
}

private fun String.toPascalCase(): String =
    split('_', '-', ' ').joinToString("") { part ->
        part.lowercase().replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }

private data class TypeInfo(
    val kotlinType: String,
    val delegate: String,
    val propertyTypeExpr: String,
    val defaultValue: String,
) {
    val kotlinTypeWithoutNullability: String get() = kotlinType.removeSuffix("?")
}
