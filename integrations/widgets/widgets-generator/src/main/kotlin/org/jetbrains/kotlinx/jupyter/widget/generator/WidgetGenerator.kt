package org.jetbrains.kotlinx.jupyter.widget.generator

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.doubleOrNull
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.json.intOrNull
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

private const val GENERATED_NOTICE = """// Generated by widgets-generator. Do not edit manually."""

private const val WIDGETS_PACKAGE = "org.jetbrains.kotlinx.jupyter.widget"
private const val WIDGET_TYPES_PACKAGE = "$WIDGETS_PACKAGE.model.types"
private const val WIDGET_LIBRARY_PACKAGE = "$WIDGETS_PACKAGE.library"

private val hiddenAttributeNames =
    setOf(
        "_model_name",
        "_model_module",
        "_model_module_version",
        "_view_name",
        "_view_module",
        "_view_module_version",
    )

@Serializable
private data class WidgetSchema(
    val attributes: List<AttributeSchema>,
    val model: WidgetTypeSchema,
    val view: WidgetTypeSchema,
)

@Serializable
private data class WidgetTypeSchema(
    val module: String,
    val name: String?,
    val version: String,
)

@Serializable
private data class AttributeSchema(
    val name: String,
    val type: AttributeType,
    val default: JsonElement,
    @SerialName("allow_none") val allowNone: Boolean = false,
    val enum: List<String> = emptyList(),
    val help: String = "",
    val items: AttributeItems? = null,
    val widget: String? = null,
    @SerialName("union_attributes") val unionAttributes: List<JsonObject> = emptyList(),
)

@Serializable
private data class AttributeItems(
    val type: AttributeType,
    val widget: String? = null,
)

private object AttributeTypeSerializer {
    fun serialize(type: AttributeType): JsonElement =
        when (type) {
            is AttributeType.Single -> JsonPrimitive(type.name)
            is AttributeType.Union -> Json.encodeToJsonElement(type.options.map { serialize(it) })
        }
}

@Serializable(with = AttributeType.Companion::class)
private sealed class AttributeType {
    data class Single(
        val name: String,
    ) : AttributeType()

    data class Union(
        val options: List<Single>,
    ) : AttributeType()

    companion object : kotlinx.serialization.KSerializer<AttributeType> {
        private val delegate = JsonElement.serializer()

        override val descriptor = delegate.descriptor

        override fun deserialize(decoder: kotlinx.serialization.encoding.Decoder): AttributeType =
            when (val element = delegate.deserialize(decoder)) {
                is JsonPrimitive -> Single(element.content)
                else -> {
                    val options = Json.decodeFromJsonElement<List<JsonPrimitive>>(element)
                    Union(options.map { Single(it.content) })
                }
            }

        override fun serialize(
            encoder: kotlinx.serialization.encoding.Encoder,
            value: AttributeType,
        ) {
            encoder.encodeSerializableValue(delegate, AttributeTypeSerializer.serialize(value))
        }
    }
}

public fun main() {
    val projectRoot =
        Path
            .of(".")
            .toAbsolutePath()
            .normalize()
            .parent
            ?.parent
            ?.parent
            ?: error("Unable to resolve project root")

    val generator = WidgetGenerator(projectRoot)
    generator.generate()
}

private class WidgetGenerator(
    projectRoot: Path,
) {
    private val json = Json { ignoreUnknownKeys = true }

    private val schemaPath = projectRoot / "integrations/widgets/widgets-generator/schema.json"
    private val apiOutput = projectRoot / "integrations/widgets/widgets-api/src/generated/kotlin"
    private val jupyterOutput = projectRoot / "integrations/widgets/widgets-jupyter/src/generated/kotlin"

    fun generate() {
        val schemaText = schemaPath.readText()
        val widgets = json.decodeFromString<List<WidgetSchema>>(schemaText)

        recreateDirectory(apiOutput)
        recreateDirectory(jupyterOutput)

        val widgetInfos = widgets.map { it.toInfo() }
        widgetInfos.forEach { generateWidgetFile(it) }
        generateFactoryRegistry(widgetInfos)
        generateJupyterHelpers(widgetInfos)
    }

    private fun WidgetSchema.toInfo(): WidgetInfo {
        val baseName =
            model.name?.removeSuffix("Model")
                ?: view.name?.removeSuffix("View")
                ?: error("Either model or view name must be specified")
        val className = if (baseName.endsWith("Widget")) baseName else "${baseName}Widget"
        val functionName = baseName.toCamelCase()
        return WidgetInfo(baseName, className, functionName, this)
    }

    private fun generateWidgetFile(info: WidgetInfo) {
        val packageName = "$WIDGETS_PACKAGE.library"
        val filePath = apiOutput / packageName.replace('.', '/') / "${info.className}.kt"
        filePath.parent.createDirectories()

        val builder = StringBuilder()
        val imports =
            sortedSetOf<String>().apply {
                for (importName in listOf(
                    "WidgetManager",
                    "model.DefaultWidgetFactory",
                    "model.DefaultWidgetModel",
                    "model.WidgetSpec",
                    "model.createAndRegisterWidget",
                )) {
                    add("$WIDGETS_PACKAGE.$importName")
                }
            }

        val helperDeclarations = mutableListOf<String>()
        val properties =
            info.schema.attributes.mapNotNull { attribute ->
                if (attribute.name in hiddenAttributeNames) return@mapNotNull null
                createProperty(attribute, info, helperDeclarations, imports)
            }

        builder.appendLine(GENERATED_NOTICE)
        builder.appendLine("package $packageName")
        builder.appendLine()
        if (imports.isNotEmpty()) {
            imports.forEach { builder.appendLine("import $it") }
            builder.appendLine()
        }

        helperDeclarations.forEach { declaration ->
            builder.appendLine(declaration)
            builder.appendLine()
        }

        val specName = "${info.functionName}Spec"
        builder.appendLine("private val $specName = WidgetSpec(")
        builder.appendLine("    modelName = \"${info.schema.model.name}\",")
        builder.appendLine("    modelModule = \"${info.schema.model.module}\",")
        builder.appendLine("    modelModuleVersion = \"${info.schema.model.version}\",")
        builder.appendLine("    viewName = \"${info.schema.view.name}\",")
        builder.appendLine("    viewModule = \"${info.schema.view.module}\",")
        builder.appendLine("    viewModuleVersion = \"${info.schema.view.version}\",")
        builder.appendLine(")")
        builder.appendLine()

        builder.appendLine(
            "public fun WidgetManager.${info.functionName}(): ${info.className} = createAndRegisterWidget(${info.className}.Factory)",
        )
        builder.appendLine()
        builder.appendLine("public class ${info.className} internal constructor(")
        builder.appendLine("    widgetManager: WidgetManager,")
        builder.appendLine(") : DefaultWidgetModel($specName, widgetManager) {")
        builder.appendLine("    internal object Factory : DefaultWidgetFactory<${info.className}>($specName, ::${info.className})")
        builder.appendLine()

        properties.forEach { builder.appendLine(it) }

        builder.appendLine("}")

        filePath.writeText(builder.toString())
    }

    private fun createProperty(
        attribute: AttributeSchema,
        widgetInfo: WidgetInfo,
        helperDeclarations: MutableList<String>,
        imports: MutableSet<String>,
    ): String {
        val context = GenerationContext(widgetInfo, helperDeclarations, imports)
        val typeInfo = attribute.toTypeInfo(context)
        return buildString {
            append("    public var ${attribute.name.toPascalCase().toCamelCase()}: ${typeInfo.kotlinType} by ")
            append(typeInfo.delegate)
        }
    }

    private data class GenerationContext(
        val widgetInfo: WidgetInfo,
        val helperDeclarations: MutableList<String>,
        val imports: MutableSet<String>,
    )

    private val AttributeSchema.isNullable: Boolean get() = allowNone || default is JsonNull

    private fun AttributeSchema.toNullableTypeExpr(
        typeExpr: String,
        imports: MutableSet<String>,
    ): String =
        if (isNullable) {
            imports.add("$WIDGET_TYPES_PACKAGE.compound.NullableType")
            "NullableType($typeExpr)"
        } else {
            typeExpr
        }

    private fun AttributeSchema.toKotlinType(baseType: String): String = if (isNullable) "$baseType?" else baseType

    private fun AttributeSchema.toTypeInfo(context: GenerationContext): TypeInfo =
        when (type) {
            is AttributeType.Single -> toSingleTypeInfo(context)
            is AttributeType.Union -> toUnionTypeInfo(context)
        }

    private fun AttributeSchema.toUnionTypeInfo(context: GenerationContext): TypeInfo {
        val nameForType = "${context.widgetInfo.className}${name.toPascalCase()}UnionType"
        val optionSchemas =
            if (unionAttributes.isNotEmpty()) {
                unionAttributes.map { json.decodeFromJsonElement<AttributeSchema>(it.addMissingFields(this)) }
            } else {
                when (val t = type) {
                    is AttributeType.Single -> listOf(this.copy(type = t))
                    is AttributeType.Union ->
                        t.options.map { opt ->
                            this.copy(type = opt)
                        }
                }
            }

        val candidateInfos =
            optionSchemas.map { candidate ->
                candidate.toSingleTypeInfo(context)
            }

        val serializerSelector =
            "{ value ->\n        when (value) {\n${candidateInfos.joinToString(separator = "\n") { info ->
                val checkType =
                    info.kotlinTypeWithoutNullability.let {
                        if (it.contains("<")) it.replace(Regex("<.*>"), "<*>") else it
                    }
                "            is $checkType -> ${info.propertyTypeExpr}"
            }}\n            else -> ${candidateInfos.last().propertyTypeExpr}\n        }\n    }"

        context.imports.add("$WIDGET_TYPES_PACKAGE.compound.UnionType")
        val deserializers =
            candidateInfos.joinToString(", ") {
                it.propertyTypeExpr
            }
        val unionDeclaration =
            buildString {
                appendLine("private val $nameForType = UnionType<Any>(")
                appendLine("    name = \"$name\",")
                appendLine("    default = ${candidateInfos.first().defaultValue},")
                appendLine("    serializerSelector = $serializerSelector,")
                appendLine("    deserializers = listOf($deserializers),")
                appendLine(")")
            }

        context.helperDeclarations += unionDeclaration

        val defaultValue = candidateInfos.first().defaultValue
        return TypeInfo("Any", "prop(\"$name\", $nameForType, $defaultValue)", nameForType, defaultValue)
    }

    private fun JsonObject.addMissingFields(base: AttributeSchema): JsonObject {
        val newMap = toMutableMap()
        if ("name" !in newMap) newMap["name"] = JsonPrimitive(base.name)
        if ("default" !in newMap) newMap["default"] = base.default
        if ("help" !in newMap) newMap["help"] = JsonPrimitive(base.help)
        return JsonObject(newMap)
    }

    private fun AttributeSchema.toSingleTypeInfo(context: GenerationContext): TypeInfo {
        if (enum.isNotEmpty()) {
            return toEnumType(context)
        }

        return when (val t = type) {
            is AttributeType.Single ->
                when (t.name) {
                    "string" -> basicType("String", "stringProp", context, this)
                    "bool" -> basicType("Boolean", "boolProp", context, this)
                    "int" -> basicType("Int", "intProp", context, this)
                    "float" -> basicType("Double", "doubleProp", context, this)
                    "bytes" -> basicType("ByteArray", "bytesProp", context, this)
                    "Datetime" -> timedType("java.time.Instant", "$WIDGET_TYPES_PACKAGE.datetime.DatetimeType", context)
                    "Date" -> timedType("java.time.LocalDate", "$WIDGET_TYPES_PACKAGE.datetime.DateType", context)
                    "Time" -> timedType("java.time.LocalTime", "$WIDGET_TYPES_PACKAGE.datetime.TimeType", context)
                    "reference" -> referenceType(context)
                    "object" -> objectType(context)
                    "array" -> arrayType(context)
                    else -> error("Unsupported type $type")
                }
            else -> error("Expected Single type, but got $type")
        }
    }

    private fun AttributeSchema.objectType(context: GenerationContext): TypeInfo {
        context.imports.add("$WIDGET_TYPES_PACKAGE.compound.RawObjectType")
        val kotlinType = toKotlinType("Map<String, Any?>")
        val propertyTypeExpr = toNullableTypeExpr("RawObjectType", context.imports)
        val defaultValue = if (isNullable) "null" else "emptyMap()"
        val delegate = "prop(\"$name\", $propertyTypeExpr, $defaultValue)"
        return TypeInfo(kotlinType, delegate, propertyTypeExpr, defaultValue)
    }

    private fun AttributeSchema.referenceType(context: GenerationContext): TypeInfo {
        val targetClass = referencedClassName()
        val defaultValue =
            if ((default as? JsonPrimitive)?.content == "reference to new instance") {
                "widgetManager.${targetClass.toCamelCase().removeSuffix("Widget")}()"
            } else {
                "null"
            }

        if (targetClass == "WidgetModel") {
            context.imports.add("$WIDGETS_PACKAGE.model.WidgetModel")
        }
        context.imports.add("$WIDGET_TYPES_PACKAGE.widget.WidgetReferenceType")

        val propertyTypeExpr = "WidgetReferenceType<$targetClass>()"
        val actualTypeExpr = toNullableTypeExpr(propertyTypeExpr, context.imports)
        val kotlinType = toKotlinType(targetClass)
        val delegateName = if (isNullable) "nullableWidgetProp" else "widgetProp"
        val delegate = "$delegateName(\"$name\", $defaultValue)"
        return TypeInfo(kotlinType, delegate, actualTypeExpr, defaultValue)
    }

    private fun AttributeSchema.arrayType(context: GenerationContext): TypeInfo {
        val elementInfo =
            if (items == null) {
                context.imports.add("$WIDGET_TYPES_PACKAGE.primitive.AnyType")
                TypeInfo("Any?", "prop(\"$name-item\", AnyType, null)", "AnyType", "null")
            } else {
                items.toElementType(context)
            }
        context.imports.add("$WIDGET_TYPES_PACKAGE.compound.ArrayType")
        val baseTypeExpr = "ArrayType(${elementInfo.propertyTypeExpr})"
        val propertyTypeExpr = toNullableTypeExpr(baseTypeExpr, context.imports)
        val defaultValue = if (isNullable) "null" else defaultArrayValue(elementInfo.kotlinType, default)
        val kotlinType = toKotlinType("List<${elementInfo.kotlinType}>")
        val delegate = "prop(\"$name\", $propertyTypeExpr, $defaultValue)"
        return TypeInfo(kotlinType, delegate, propertyTypeExpr, defaultValue)
    }

    private fun AttributeItems.toElementType(context: GenerationContext): TypeInfo {
        val schema = AttributeSchema(name = "item", type = type, default = JsonNull, widget = widget)
        return schema.toSingleTypeInfo(context)
    }

    private fun AttributeSchema.timedType(
        kotlinType: String,
        typeImport: String,
        context: GenerationContext,
    ): TypeInfo {
        context.imports.add(typeImport)
        val propertyTypeExpr = typeImport.substringAfterLast('.')
        val actualTypeExpr = toNullableTypeExpr(propertyTypeExpr, context.imports)
        val kotlinTypeName = toKotlinType(kotlinType)
        val defaultValue = renderLiteral(kotlinTypeName, default)
        val delegate = "prop(\"$name\", $actualTypeExpr, $defaultValue)"
        return TypeInfo(kotlinTypeName, delegate, actualTypeExpr, defaultValue)
    }

    private fun basicType(
        kotlinType: String,
        delegateName: String,
        context: GenerationContext,
        attribute: AttributeSchema,
    ): TypeInfo {
        val typeName = attribute.toKotlinType(kotlinType)
        val defaultValue = renderLiteral(typeName, attribute.default)
        val baseTypeExpr = kotlinType.toPrimitiveTypeName()
        context.imports.add("$WIDGET_TYPES_PACKAGE.primitive.$baseTypeExpr")

        return if (attribute.isNullable) {
            val propertyTypeExpr = attribute.toNullableTypeExpr(baseTypeExpr, context.imports)
            val delegate = "prop(\"${attribute.name}\", $propertyTypeExpr, $defaultValue)"
            TypeInfo(typeName, delegate, propertyTypeExpr, defaultValue)
        } else {
            TypeInfo(typeName, "$delegateName(\"${attribute.name}\", $defaultValue)", baseTypeExpr, defaultValue)
        }
    }

    private fun AttributeSchema.toEnumType(context: GenerationContext): TypeInfo {
        val enumName = "${context.widgetInfo.className}${name.toPascalCase()}"
        context.imports.add("$WIDGET_TYPES_PACKAGE.enums.WidgetEnum")
        context.imports.add("$WIDGET_TYPES_PACKAGE.enums.WidgetEnumEntry")
        context.imports.add("$WIDGET_TYPES_PACKAGE.enums.WidgetEnumType")

        val entries =
            enum.joinToString("\n") { value ->
                val entryName = if (value.isEmpty()) "Default" else value.toPascalCase()
                "    public val $entryName: WidgetEnumEntry<$enumName> by entry(\"$value\")"
            }

        val enumDeclaration = "public object $enumName : WidgetEnum<$enumName>() {\n$entries\n}"
        context.helperDeclarations += enumDeclaration

        val defaultEntry = (default as? JsonPrimitive)?.content?.takeUnless { it == "null" }
        val defaultExpression =
            when {
                defaultEntry == null || defaultEntry !in enum -> "null"
                defaultEntry.isEmpty() -> "$enumName.Default"
                else -> "$enumName.${defaultEntry.toPascalCase()}"
            }

        val typeDefaultEntry = defaultEntry?.takeIf { it in enum } ?: enum.first()
        val typeDefaultEntryName = typeDefaultEntry.ifEmpty { "Default" }
        val baseTypeExpr = "WidgetEnumType($enumName, $enumName.${typeDefaultEntryName.toPascalCase()})"
        val typeExpr = toNullableTypeExpr(baseTypeExpr, context.imports)

        val kotlinType = toKotlinType("WidgetEnumEntry<$enumName>")
        val delegate = "prop(\"$name\", $typeExpr, $defaultExpression)"
        return TypeInfo(kotlinType, delegate, typeExpr, defaultExpression)
    }

    private fun AttributeSchema.referencedClassName(): String {
        val base = widget ?: error("Reference widget is not specified")
        if (base == "Widget") return "WidgetModel"
        if (base == "Axis") return "ControllerAxisWidget"
        return if (base.endsWith("Widget")) base else "${base}Widget"
    }

    private fun defaultArrayValue(
        elementKotlinType: String,
        value: JsonElement,
    ): String =
        if (value is kotlinx.serialization.json.JsonArray && value.isNotEmpty()) {
            val renderedItems = value.joinToString(", ") { renderLiteral(elementKotlinType, it) }
            "listOf($renderedItems)"
        } else {
            "emptyList()"
        }

    private fun renderLiteral(
        kotlinType: String,
        value: JsonElement,
    ): String =
        when {
            value is JsonNull -> "null"
            kotlinType == "ByteArray" || kotlinType == "ByteArray?" -> "byteArrayOf()"
            value is JsonPrimitive -> {
                if (value.isString) {
                    val quoted =
                        value.content
                            .replace("\\", "\\\\")
                            .replace("\"", "\\\"")
                    "\"$quoted\""
                } else {
                    val primitiveValue =
                        value.booleanOrNull
                            ?: value.intOrNull
                            ?: value.doubleOrNull
                            ?: error("Unsupported primitive value for $kotlinType: $value")
                    primitiveValue.toString()
                }
            }
            else -> error("Unsupported literal for $kotlinType: $value")
        }

    private fun String.toPrimitiveTypeName(): String =
        when (this) {
            "Int" -> "IntType"
            "Double" -> "FloatType"
            "Boolean" -> "BooleanType"
            "String" -> "StringType"
            "ByteArray" -> "BytesType"
            else -> error("Unsupported primitive type $this")
        }

    private fun generateFactoryRegistry(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGET_LIBRARY_PACKAGE.registry"
        val filePath = apiOutput / packageName.replace('.', '/') / "DefaultWidgetFactories.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.className }
        val content =
            buildString {
                appendLine(GENERATED_NOTICE)
                appendLine("package $packageName")
                appendLine()
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                appendLine("import $WIDGETS_PACKAGE.model.WidgetFactory")
                appendLine()
                appendLine("internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(")
                for (info in sortedInfos) {
                    appendLine("    ${info.className}.Factory,")
                }
                appendLine(")")
            }

        filePath.writeText(content)
    }

    private fun generateJupyterHelpers(widgetInfos: List<WidgetInfo>) {
        val packageName = "$WIDGETS_PACKAGE.integration"
        val filePath = jupyterOutput / packageName.replace('.', '/') / "JupyterWidgetLibrary.kt"
        filePath.parent.createDirectories()

        val sortedInfos = widgetInfos.sortedInImportsOrder { it.functionName }
        val content =
            buildString {
                appendLine(GENERATED_NOTICE)
                appendLine("package $packageName")
                appendLine()
                for (info in widgetInfos.sortedInImportsOrder { it.className }) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.className}")
                }
                for (info in sortedInfos) {
                    appendLine("import $WIDGET_LIBRARY_PACKAGE.${info.functionName}")
                }
                appendLine()
                for (info in sortedInfos) {
                    appendLine("public fun ${info.functionName}Widget(): ${info.className} = globalWidgetManager.${info.functionName}()")
                    appendLine()
                }
            }

        filePath.writeText(content)
    }

    private fun <T> List<T>.sortedInImportsOrder(representAsString: (T) -> String): List<T> =
        sortedWith { a, b ->
            when {
                representAsString(a).startsWith(representAsString(b)) -> 1
                representAsString(b).startsWith(representAsString(a)) -> -1
                else -> representAsString(a).compareTo(representAsString(b))
            }
        }

    private fun recreateDirectory(path: Path) {
        if (path.exists()) {
            Files
                .walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(Files::delete)
        }
        path.createDirectories()
    }
}

private data class WidgetInfo(
    val baseName: String,
    val className: String,
    val functionName: String,
    val schema: WidgetSchema,
)

private val commonAbbreviations =
    setOf(
        "html",
    )

private fun String.toCamelCase(): String {
    if (isEmpty()) return this
    if (length == 1) return lowercase()
    val abbreviation = commonAbbreviations.find { startsWith(it, ignoreCase = true) }
    val suffixStartIndex =
        if (abbreviation == null) {
            var index = 1
            while (index < length && this[index].isUpperCase()) {
                index++
            }
            index
        } else {
            abbreviation.length
        }

    val prefix = substring(0, suffixStartIndex)
    val rest = substring(suffixStartIndex)
    return prefix.lowercase() + rest
}

private fun String.toPascalCase(): String =
    split('_', '-', ' ').joinToString("") { part ->
        part.lowercase().replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }

private data class TypeInfo(
    val kotlinType: String,
    val delegate: String,
    val propertyTypeExpr: String,
    val defaultValue: String,
) {
    val kotlinTypeWithoutNullability: String get() = kotlinType.removeSuffix("?")
}
