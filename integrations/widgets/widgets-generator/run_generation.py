import json
from pathlib import Path
import shutil
import re
from dataclasses import dataclass

schema_path = Path(__file__).parent / "schema.json"
api_output = Path(__file__).parents[1] / "widgets-api/src/generated/kotlin"
jupyter_output = Path(__file__).parents[1] / "widgets-jupyter/src/generated/kotlin"

for path in (api_output, jupyter_output):
    if path.exists():
        shutil.rmtree(path)
    path.mkdir(parents=True, exist_ok=True)

@dataclass
class TypeInfo:
    kotlin_type: str
    delegate: str
    property_type_expr: str
    default_value: str

    @property
    def kotlin_type_without_nullability(self):
        return self.kotlin_type[:-1] if self.kotlin_type.endswith('?') else self.kotlin_type

def to_camel(name: str) -> str:
    if not name:
        return name
    if len(name) == 1:
        return name.lower()
    index = 1
    while index < len(name) and name[index].isupper():
        index += 1
    prefix = name[:index]
    rest = name[index:]
    return prefix.lower() + rest

def to_pascal(name: str) -> str:
    parts = [p for p in re.split(r'[\s_-]+', name) if p]
    return ''.join(p.lower().capitalize() for p in parts)

GENERATED_NOTICE = "// Generated by widgets-generator. Do not edit manually."

def escape_string(value: str) -> str:
    return value.replace('\\', r'\\').replace('"', r'\\"')

def default_value_for_type(kotlin_type: str, value):
    if value is None:
        return 'null'
    if kotlin_type in ('ByteArray', 'ByteArray?'):
        return 'byteArrayOf()'
    if isinstance(value, str):
        return f'"{escape_string(value)}"'
    if isinstance(value, bool):
        return 'true' if value else 'false'
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        text = repr(float(value))
        if text.endswith('.0'):
            text = text[:-2] + '.0'
        return text
    raise ValueError(f'Unsupported default {value!r} for {kotlin_type}')

def render_literal(element_type: str, nullable_type: str, value):
    if value is None:
        return 'null'
    if isinstance(value, str):
        return f'"{escape_string(value)}"'
    if isinstance(value, bool):
        return 'true' if value else 'false'
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        text = repr(float(value))
        if text.endswith('.0'):
            text = text[:-2] + '.0'
        return text
    raise ValueError(f'Unsupported array literal for {element_type}/{nullable_type}: {value!r}')

def default_array_value(element_type: str, nullable_type: str, value):
    if isinstance(value, list) and value:
        rendered = ', '.join(render_literal(element_type, nullable_type, v) for v in value)
        return f'listOf({rendered})'
    return 'emptyList()'

def referenced_class_name(widget):
    if widget is None:
        raise ValueError('Reference widget is not specified')
    if widget == 'Widget':
        return 'WidgetModel'
    return widget if widget.endswith('Widget') else f'{widget}Widget'

def primitive_name(kotlin_type):
    return {
        'Int': 'IntType',
        'Double': 'FloatType',
        'Boolean': 'BooleanType',
        'String': 'StringType',
        'ByteArray': 'BytesType',
    }[kotlin_type]

def basic_type(attr, kotlin_type, delegate_name, imports):
    nullable = attr.get('allow_none', False) or attr['default'] is None
    type_name = f'{kotlin_type}?' if nullable else kotlin_type
    default_value = default_value_for_type(type_name, attr['default'])
    if nullable:
        imports.update({
            'org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType',
            f'org.jetbrains.kotlinx.jupyter.widget.model.types.primitive.{primitive_name(kotlin_type)}',
        })
        property_type_expr = f'NullableType({primitive_name(kotlin_type)})'
        delegate = f'prop("{attr["name"]}", {property_type_expr}, {default_value})'
        return TypeInfo(type_name, delegate, property_type_expr, default_value)
    delegate = f'{delegate_name}("{attr["name"]}", {default_value})'
    return TypeInfo(type_name, delegate, primitive_name(kotlin_type), default_value)

def timed_type(attr, kotlin_type, type_import, imports):
    imports.add(type_import)
    property_type_expr = type_import.split('.')[-1]
    nullable = attr.get('allow_none', False) or attr['default'] is None
    actual_expr = property_type_expr
    if nullable:
        imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType')
        actual_expr = f'NullableType({property_type_expr})'
    type_name = f'{kotlin_type}?' if nullable else kotlin_type
    default_value = default_value_for_type(type_name, attr['default'])
    delegate = f'prop("{attr["name"]}", {actual_expr}, {default_value})'
    return TypeInfo(type_name, delegate, actual_expr, default_value)

def enum_type(attr, widget_info, helper_decls, imports):
    enum_name = f'{widget_info["class_name"]}{to_pascal(attr["name"])}Enum'
    imports.update({
        'org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnum',
        'org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnumEntry',
        'org.jetbrains.kotlinx.jupyter.widget.model.types.enums.WidgetEnumType',
        'org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType',
    })
    entries = '\n'.join(
        f'    public val {to_pascal(value)}: WidgetEnumEntry<{enum_name}> by entry("{value}")'
        for value in attr['enum']
    )
    helper_decls.append(f'public object {enum_name} : WidgetEnum<{enum_name}>() {{\n{entries}\n}}')
    default_entry = attr.get('default')
    nullable = attr.get('allow_none', False) or attr['default'] is None
    default_expr = 'null' if default_entry is None else f'{enum_name}.{to_pascal(default_entry)}'
    type_default = default_entry if default_entry is not None else attr['enum'][0]
    type_expr = f'WidgetEnumType({enum_name}, {enum_name}.{to_pascal(type_default)})'
    if nullable:
        type_expr = f'NullableType({type_expr})'
        kotlin_type = f'WidgetEnumEntry<{enum_name}>?'
    else:
        kotlin_type = f'WidgetEnumEntry<{enum_name}>'
    delegate = f'prop("{attr["name"]}", {type_expr}, {default_expr})'
    return TypeInfo(kotlin_type, delegate, type_expr, default_expr)

def reference_type(attr, widget_info, imports):
    target_class = referenced_class_name(attr.get('widget'))
    default_value = 'null'
    if attr['default'] == 'reference to new instance':
        default_value = f'widgetManager.{to_camel(target_class)}()'
    if target_class == 'WidgetModel':
        imports.add('org.jetbrains.kotlinx.jupyter.widget.model.WidgetModel')
    imports.update({
        'org.jetbrains.kotlinx.jupyter.widget.model.types.widget.WidgetReferenceType',
        'org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType',
    })
    kotlin_type = f'{target_class}?'
    delegate = f'widgetProp("{attr["name"]}", {default_value})'
    return TypeInfo(kotlin_type, delegate, f'WidgetReferenceType<{target_class}>()', default_value)

def element_type(items_attr, widget_info, helper_decls, imports):
    schema = {
        'name': 'item',
        'type': items_attr['type'],
        'default': None,
        'enum': items_attr.get('enum', []),
        'allow_none': items_attr.get('allow_none', False),
        'items': items_attr.get('items'),
        'widget': items_attr.get('widget'),
        'union_attributes': items_attr.get('union_attributes', []),
        'help': '',
    }
    return to_type_info(schema, widget_info, helper_decls, imports)

def array_type(attr, widget_info, helper_decls, imports):
    items = attr.get('items')
    if items is None:
        imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.primitive.AnyType')
        element_info = TypeInfo('Any?', 'prop("item", AnyType, null)', 'AnyType', 'null')
    else:
        element_info = element_type(items, widget_info, helper_decls, imports)
    imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.compound.ArrayType')
    property_type_expr = f'ArrayType({element_info.property_type_expr})'
    default_value = default_array_value(element_info.kotlin_type_without_nullability, element_info.kotlin_type, attr['default'])
    delegate = f'prop("{attr["name"]}", {property_type_expr}, {default_value})'
    return TypeInfo(f'List<{element_info.kotlin_type}>', delegate, property_type_expr, default_value)

def union_type(attr, widget_info, helper_decls, imports):
    name_for_type = f'{widget_info["class_name"]}{to_pascal(attr["name"])}UnionType'
    option_types = attr.get('union_attributes') or []
    normalized = []
    for candidate in option_types:
        data = dict(candidate)
        data.setdefault('name', attr['name'])
        data.setdefault('default', attr.get('default'))
        data.setdefault('enum', data.get('enum', []))
        data.setdefault('allow_none', data.get('allow_none', attr.get('allow_none', False)))
        data.setdefault('items', data.get('items'))
        data.setdefault('widget', data.get('widget', attr.get('widget')))
        data.setdefault('union_attributes', [])
        if data['enum'] and data.get('default') not in data['enum']:
            data['default'] = data['enum'][0]
        normalized.append(data)
    if not normalized:
        normalized = [
            {
                'name': attr['name'],
                'type': opt,
                'default': attr.get('default'),
                'enum': attr.get('enum', []),
                'allow_none': attr.get('allow_none', False),
                'items': attr.get('items'),
                'widget': attr.get('widget'),
                'union_attributes': [],
            }
            for opt in attr['type']
        ]
    candidate_infos = [
        to_type_info(candidate, widget_info, helper_decls, imports)
        for candidate in normalized
    ]
    imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.compound.UnionType')
    serializer_lines = '\n'.join(
        f'            is {info.kotlin_type_without_nullability} -> {info.property_type_expr}'
        for info in candidate_infos
    )
    serializer = (
        '{ value ->\n'
        '        when (value) {\n'
        f'{serializer_lines}\n'
        f'            else -> {candidate_infos[-1].property_type_expr}\n'
        '        }\n'
        '    }'
    )
    deserializers = ', '.join(info.property_type_expr for info in candidate_infos)
    union_decl = (
        f'private val {name_for_type} = UnionType<Any>(\n'
        f'    name = "{attr["name"]}",\n'
        f'    default = {candidate_infos[0].default_value},\n'
        f'    serializerSelector = {serializer},\n'
        f'    deserializers = listOf({deserializers}),\n'
        f')'
    )
    helper_decls.append(union_decl)
    default_value = candidate_infos[0].default_value
    return TypeInfo('Any', f'prop("{attr["name"]}", {name_for_type}, {default_value})', name_for_type, default_value)

def to_type_info(attr, widget_info, helper_decls, imports):
    attr_type = attr['type']
    if isinstance(attr_type, list):
        return union_type(attr, widget_info, helper_decls, imports)
    if attr.get('enum'):
        return enum_type(attr, widget_info, helper_decls, imports)
    tname = attr_type if isinstance(attr_type, str) else attr_type['name']
    if tname == 'string':
        return basic_type(attr, 'String', 'stringProp', imports)
    if tname == 'bool':
        return basic_type(attr, 'Boolean', 'boolProp', imports)
    if tname == 'int':
        return basic_type(attr, 'Int', 'intProp', imports)
    if tname == 'float':
        return basic_type(attr, 'Double', 'doubleProp', imports)
    if tname == 'bytes':
        return basic_type(attr, 'ByteArray', 'bytesProp', imports)
    if tname == 'Datetime':
        return timed_type(attr, 'java.time.Instant', 'org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.DatetimeType', imports)
    if tname == 'Date':
        return timed_type(attr, 'java.time.LocalDate', 'org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.DateType', imports)
    if tname == 'Time':
        return timed_type(attr, 'java.time.LocalTime', 'org.jetbrains.kotlinx.jupyter.widget.model.types.datetime.TimeType', imports)
    if tname == 'reference':
        return reference_type(attr, widget_info, imports)
    if tname == 'array':
        return array_type(attr, widget_info, helper_decls, imports)
    if tname == 'object':
        imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.compound.RawObjectType')
        nullable = attr.get('allow_none', False) or attr['default'] is None
        kotlin_type = 'Map<String, Any?>?' if nullable else 'Map<String, Any?>'
        property_type_expr = 'RawObjectType'
        if nullable:
            imports.add('org.jetbrains.kotlinx.jupyter.widget.model.types.compound.NullableType')
            property_type_expr = f'NullableType({property_type_expr})'
        delegate = f'prop("{attr["name"]}", {property_type_expr}, {"null" if nullable else "emptyMap()"})'
        return TypeInfo(kotlin_type, delegate, property_type_expr, 'null' if nullable else 'emptyMap()')
    raise ValueError(f'Unsupported type {tname}')

def generate_widget(widget):
    base_name = widget['model']['name'].removesuffix('Model')
    class_name = base_name if base_name.endswith('Widget') else f'{base_name}Widget'
    function_name = to_camel(base_name)
    widget_info = {'class_name': class_name, 'function_name': function_name}

    imports = {
        'org.jetbrains.kotlinx.jupyter.widget.WidgetManager',
        'org.jetbrains.kotlinx.jupyter.widget.model.DefaultWidgetFactory',
        'org.jetbrains.kotlinx.jupyter.widget.model.DefaultWidgetModel',
        'org.jetbrains.kotlinx.jupyter.widget.model.WidgetSpec',
        'org.jetbrains.kotlinx.jupyter.widget.model.createAndRegisterWidget',
    }
    helper_decls = []
    properties = []
    for attr in widget['attributes']:
        type_info = to_type_info(attr, widget_info, helper_decls, imports)
        properties.append(f'    public var {attr["name"]}: {type_info.kotlin_type} by {type_info.delegate}')
    package_name = 'org.jetbrains.kotlinx.jupyter.widget.library'
    file_path = api_output / package_name.replace('.', '/') / f'{class_name}.kt'
    file_path.parent.mkdir(parents=True, exist_ok=True)
    lines = []
    lines.append(GENERATED_NOTICE)
    lines.append(f'package {package_name}\n')
    for imp in sorted(imports):
        lines.append(f'import {imp}')
    lines.append('')
    for helper in helper_decls:
        lines.append(helper)
        lines.append('')
    spec_name = f'{function_name}Spec'
    lines.append(f'private val {spec_name} = WidgetSpec(')
    lines.append(f'    modelName = "{widget["model"]["name"]}",')
    lines.append(f'    modelModule = "{widget["model"]["module"]}",')
    lines.append(f'    modelModuleVersion = "{widget["model"]["version"]}",')
    lines.append(f'    viewName = "{widget["view"]["name"]}",')
    lines.append(f'    viewModule = "{widget["view"]["module"]}",')
    lines.append(f'    viewModuleVersion = "{widget["view"]["version"]}",')
    lines.append(')\n')
    lines.append(f'public fun WidgetManager.{function_name}(): {class_name} = createAndRegisterWidget({class_name}.Factory)\n')
    lines.append(f'public class {class_name} internal constructor(')
    lines.append('    widgetManager: WidgetManager,')
    lines.append(f') : DefaultWidgetModel({spec_name}, widgetManager) {{')
    lines.append(f'    internal object Factory : DefaultWidgetFactory<{class_name}>({spec_name}, ::{class_name})\n')
    lines.extend(properties)
    lines.append('}')
    file_path.write_text('\n'.join(lines))
    return {'class_name': class_name, 'function_name': function_name}

widgets = json.load(schema_path.open())
widget_infos = [generate_widget(w) for w in widgets]

registry_package = 'org.jetbrains.kotlinx.jupyter.widget.library.registry'
reg_path = api_output / registry_package.replace('.', '/') / 'DefaultWidgetFactories.kt'
reg_path.parent.mkdir(parents=True, exist_ok=True)
content = [GENERATED_NOTICE, f'package {registry_package}\n', 'import org.jetbrains.kotlinx.jupyter.widget.library.*', 'import org.jetbrains.kotlinx.jupyter.widget.model.WidgetFactory\n']
content.append('internal val defaultWidgetFactories = listOf<WidgetFactory<*>>(')
for info in sorted(widget_infos, key=lambda x: x['class_name']):
    content.append(f'    {info["class_name"]}.Factory,')
content.append(')')
reg_path.write_text('\n'.join(content))

integration_package = 'org.jetbrains.kotlinx.jupyter.widget.integration'
jupyter_path = jupyter_output / integration_package.replace('.', '/') / 'JupyterWidgetLibrary.kt'
jupyter_path.parent.mkdir(parents=True, exist_ok=True)
jupyter_lines = [GENERATED_NOTICE, f'package {integration_package}\n', 'import org.jetbrains.kotlinx.jupyter.widget.integration.globalWidgetManager', 'import org.jetbrains.kotlinx.jupyter.widget.library.*\n']
for info in sorted(widget_infos, key=lambda x: x['class_name']):
    jupyter_lines.append(f'public fun {info["function_name"]}Widget(): {info["class_name"]} = globalWidgetManager.{info["function_name"]}()\n')
jupyter_path.write_text('\n'.join(jupyter_lines))
