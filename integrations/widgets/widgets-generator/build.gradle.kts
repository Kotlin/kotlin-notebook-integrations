plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.serialization)
}

dependencies {
    implementation(libs.kotlinx.serialization.json)
    implementation(libs.kotlin.reflect)
    testImplementation(libs.kotlin.test)
    testImplementation(libs.test.kotlintest.assertions)
}

tasks.withType<Test> {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain {
        languageVersion.set(
            JavaLanguageVersion.of(
                JavaVersion
                    .current()
                    .majorVersion
                    .toInt(),
            ),
        )
    }
    explicitApi()
}

val generateWidgets by tasks.registering(JavaExec::class) {
    group = "generation"
    description = "Generate widget models from schema.json"
    classpath = sourceSets.main.get().runtimeClasspath
    mainClass.set("org.jetbrains.kotlinx.jupyter.widget.generator.WidgetGeneratorKt")

    val schemaFile = file("schema.json")
    val apiOutputDir = project(projects.integrations.widgets.widgetsApi.path).kotlinGeneratedDirectory
    val jupyterOutputDir = project(projects.integrations.widgets.widgetsJupyter.path).kotlinGeneratedDirectory

    inputs.file(schemaFile)
    inputs.files(sourceSets.main.get().allSource)
    outputs.dir(apiOutputDir)
    outputs.dir(jupyterOutputDir)

    args(
        schemaFile.absolutePath,
        apiOutputDir.absolutePath,
        jupyterOutputDir.absolutePath,
    )
}

abstract class CheckWidgetsRegenerated : DefaultTask() {
    @get:Inject
    abstract val execOps: ExecOperations

    @get:InputFile
    abstract val schemaFile: RegularFileProperty

    @get:InputFiles
    abstract val generatorClasspath: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val tempDir: DirectoryProperty

    @get:InputDirectory
    abstract val apiOutput: DirectoryProperty

    @get:InputDirectory
    abstract val jupyterOutput: DirectoryProperty

    @TaskAction
    fun check() {
        val apiTestDir = tempDir.get().dir("widgets-api").asFile
        val jupyterTestDir = tempDir.get().dir("widgets-jupyter").asFile

        val mainClassPath = "org.jetbrains.kotlinx.jupyter.widget.generator.WidgetGeneratorKt"

        execOps.javaexec {
            mainClass.set(mainClassPath)
            classpath = generatorClasspath
            args(
                schemaFile.get().asFile.absolutePath,
                apiTestDir.absolutePath,
                jupyterTestDir.absolutePath,
            )
        }

        fun compareDirs(
            expectedDir: File,
            actualDir: File,
        ) {
            val expectedFiles = expectedDir.walkTopDown().filter { it.isFile }.toList()
            val actualFiles = actualDir.walkTopDown().filter { it.isFile }.toList()

            val expectedRelativePaths = expectedFiles.map { it.relativeTo(expectedDir).path }.toSet()
            val actualRelativePaths = actualFiles.map { it.relativeTo(actualDir).path }.toSet()

            fun getRunGenerateTip() = "Please run ${this.project.path}:generateWidgets and commit the changes."

            if (expectedRelativePaths != actualRelativePaths) {
                val missing = expectedRelativePaths - actualRelativePaths
                val extra = actualRelativePaths - expectedRelativePaths
                throw GradleException(
                    "Generated files mismatch.\n" +
                        (if (missing.isNotEmpty()) "Missing files: $missing\n" else "") +
                        (if (extra.isNotEmpty()) "Extra files: $extra\n" else "") +
                        getRunGenerateTip(),
                )
            }

            for (relativePath in expectedRelativePaths) {
                val expectedFile = expectedDir.resolve(relativePath)
                val actualFile = actualDir.resolve(relativePath)
                if (expectedFile.readText() != actualFile.readText()) {
                    throw GradleException(
                        "Generated file $relativePath differs from the expected one. ${getRunGenerateTip()}",
                    )
                }
            }
        }

        compareDirs(apiOutput.get().asFile, apiTestDir)
        compareDirs(jupyterOutput.get().asFile, jupyterTestDir)
    }
}

val checkWidgetsRegenerated by tasks.registering(CheckWidgetsRegenerated::class) {
    group = "verification"
    description = "Ensures that the generated widgets are up-to-date with the schema and generator"

    schemaFile.set(file("schema.json"))
    generatorClasspath.from(sourceSets.main.get().runtimeClasspath)
    tempDir.set(layout.buildDirectory.dir("generated-check"))
    apiOutput.set(project(projects.integrations.widgets.widgetsApi.path).kotlinGeneratedDirectory)
    jupyterOutput.set(project(projects.integrations.widgets.widgetsJupyter.path).kotlinGeneratedDirectory)

    mustRunAfter(generateWidgets)
}

tasks.check {
    dependsOn(checkWidgetsRegenerated)
}

private val Project.kotlinGeneratedDirectory get() = file("src/generated/kotlin")
